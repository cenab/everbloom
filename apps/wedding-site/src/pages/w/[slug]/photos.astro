---
/**
 * Photo upload page
 * Route: /w/{slug}/photos
 * PRD: "Site supports multiple languages" + "Guest can set language preference"
 */
import type { RenderConfig } from '../../../types';
import { fetchSiteConfig } from '../../../lib/api';
import { getTranslations } from '../../../lib/i18n';
import WeddingLayout from '../../../components/WeddingLayout.astro';
import PasscodeGateWrapper from '../../../components/PasscodeGateWrapper.astro';
import ErrorPage from '../../../components/ErrorPage.astro';
import LanguageSelector from '../../../components/LanguageSelector.astro';

const { slug } = Astro.params;

if (!slug) {
  return Astro.redirect('/');
}

// Fetch render_config with error handling
let config: RenderConfig | null = null;
let fetchError = false;

try {
  config = await fetchSiteConfig(slug);
} catch (error) {
  // Network or API error
  fetchError = true;
}

// Determine error state for template rendering
const showError = !config || fetchError;
const errorType: 'unavailable' | 'not-found' = fetchError ? 'unavailable' : 'not-found';

// Language selection (same logic as main page)
const urlLang = Astro.url.searchParams.get('lang');
const adminLanguage = config?.language || 'en';
const effectiveLanguage = urlLang || adminLanguage;
const t = getTranslations(effectiveLanguage);

const photoEnabled = config?.features?.PHOTO_UPLOAD ?? false;
const weddingTitle = config ? `${config.wedding.partnerNames[0]} & ${config.wedding.partnerNames[1]}` : '';
const weddingSlug = config?.wedding.slug ?? '';
const theme = config?.theme ?? { primary: '#c9826b', accent: '#8fac8b', neutralLight: '#faf8f5', neutralDark: '#2d2d2d' };
---

{showError && <ErrorPage type={errorType} />}

{!showError && config && (
  <PasscodeGateWrapper config={config}>
    <WeddingLayout config={config} language={effectiveLanguage}>
      <div class="language-selector-container">
        <LanguageSelector currentLanguage={effectiveLanguage} slug={slug} />
      </div>
    <section
      class="photo-page"
      style={`--primary: ${theme.primary}; --accent: ${theme.accent}; --neutral-light: ${theme.neutralLight}; --neutral-dark: ${theme.neutralDark};`}
    >
      <div class="photo-page-content">
        <a href={`/w/${weddingSlug}${effectiveLanguage !== adminLanguage ? `?lang=${effectiveLanguage}` : ''}`} class="back-link">{t.back}</a>
        <h1 class="photo-title">{t.photosTitle}</h1>
        <p class="photo-description">{t.photosDescription}</p>

        {photoEnabled ? (
          <div class="upload-card" id="upload">
            <label class="upload-button" for="photo-files">
              {t.photosUploadButton}
            </label>
            <input id="photo-files" class="upload-input" type="file" multiple accept="image/*" />
            <p class="upload-hint">{t.photosDragDrop} {t.photosBrowseButton}</p>
            <div class="upload-list" id="upload-list" aria-live="polite"></div>
            <p class="upload-note" id="upload-note"></p>
          </div>
        ) : (
          <div class="photo-disabled">
            Photo sharing is currently closed for this event.
          </div>
        )}
      </div>
    </section>
    </WeddingLayout>
  </PasscodeGateWrapper>
)}

{!showError && photoEnabled && (
  <script
    is:inline
    define:vars={{ apiBaseUrl: import.meta.env.PUBLIC_PLATFORM_API_URL || 'http://localhost:3001/api', weddingSlug }}
  >
    document.addEventListener('DOMContentLoaded', () => {
      const fileInput = document.getElementById('photo-files');
      const uploadList = document.getElementById('upload-list');
      const uploadNote = document.getElementById('upload-note');

      if (!fileInput || !uploadList || !uploadNote) {
        return;
      }

      const maxFileSizeBytes = 10 * 1024 * 1024;
      const maxFileSizeLabel = '10 MB';

      const setNote = (message, tone) => {
        uploadNote.textContent = message;
        uploadNote.className = `upload-note${tone ? ` ${tone}` : ''}`;
      };

      const clearNote = () => {
        uploadNote.textContent = '';
        uploadNote.className = 'upload-note';
      };

      const createUploadItem = (file) => {
        const item = document.createElement('div');
        item.className = 'upload-item';

        const header = document.createElement('div');
        header.className = 'upload-item-header';

        const name = document.createElement('span');
        name.className = 'upload-item-name';
        name.textContent = file.name;

        const status = document.createElement('span');
        status.className = 'upload-item-status';
        status.textContent = 'Waiting';

        header.appendChild(name);
        header.appendChild(status);

        const progress = document.createElement('div');
        progress.className = 'upload-progress';

        const progressBar = document.createElement('div');
        progressBar.className = 'upload-progress-bar';
        progress.appendChild(progressBar);

        const retry = document.createElement('button');
        retry.type = 'button';
        retry.className = 'upload-retry hidden';
        retry.textContent = 'Retry upload';

        item.appendChild(header);
        item.appendChild(progress);
        item.appendChild(retry);
        uploadList.appendChild(item);

        return { item, status, progressBar, retry, file };
      };

      const setStatus = (entry, text, tone) => {
        entry.status.textContent = text;
        entry.status.className = `upload-item-status${tone ? ` ${tone}` : ''}`;
      };

      const updateProgress = (entry, percent) => {
        const value = Math.max(0, Math.min(100, percent));
        entry.progressBar.style.width = `${value}%`;
      };

      const requestUploadUrl = async (file) => {
        const response = await fetch(`${apiBaseUrl}/photos/upload-url`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            slug: weddingSlug,
            fileName: file.name,
            contentType: file.type || 'application/octet-stream',
            fileSize: file.size,
          }),
        });

        const result = await response.json();
        if (!result.ok) {
          throw new Error(result.error || 'UPLOAD_FAILED');
        }

        return result.data.uploadUrl;
      };

      const uploadFile = (file, uploadUrl, onProgress) =>
        new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open('POST', uploadUrl);

          xhr.upload.addEventListener('progress', (event) => {
            if (event.lengthComputable) {
              onProgress(Math.round((event.loaded / event.total) * 100));
            }
          });

          xhr.addEventListener('load', () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              resolve();
            } else {
              reject(new Error('UPLOAD_FAILED'));
            }
          });

          xhr.addEventListener('error', () => {
            reject(new Error('NETWORK_ERROR'));
          });

          const formData = new FormData();
          formData.append('file', file);
          xhr.send(formData);
        });

      const handleUpload = async (entry) => {
        entry.retry.classList.add('hidden');
        setStatus(entry, 'Preparing upload', 'pending');
        updateProgress(entry, 0);

        try {
          const uploadUrl = await requestUploadUrl(entry.file);
          setStatus(entry, 'Uploading', 'pending');
          await uploadFile(entry.file, uploadUrl, (percent) => updateProgress(entry, percent));
          setStatus(entry, 'Uploaded', 'success');
          updateProgress(entry, 100);
        } catch (error) {
          setStatus(entry, 'Upload failed', 'error');
          entry.retry.classList.remove('hidden');
        }
      };

      fileInput.addEventListener('change', () => {
        const files = Array.from(fileInput.files || []);

        uploadList.innerHTML = '';
        clearNote();

        if (!files.length) {
          return;
        }

        const entries = files.map((file) => createUploadItem(file));
        const oversized = entries.filter((entry) => entry.file.size > maxFileSizeBytes);
        const invalidType = entries.filter((entry) => !entry.file.type.startsWith('image/'));

        oversized.forEach((entry) => {
          setStatus(entry, 'File is too large', 'error');
          entry.retry.classList.add('hidden');
        });

        invalidType.forEach((entry) => {
          setStatus(entry, 'Unsupported file type', 'error');
          entry.retry.classList.add('hidden');
        });

        const uploadableEntries = entries.filter(
          (entry) =>
            entry.file.size <= maxFileSizeBytes && entry.file.type.startsWith('image/'),
        );

        const notes = [];
        if (oversized.length) {
          notes.push(`Some files were larger than ${maxFileSizeLabel} and were skipped.`);
        }
        if (invalidType.length) {
          notes.push('Only image files can be uploaded.');
        }
        if (notes.length) {
          setNote(notes.join(' '), 'error');
        }

        uploadableEntries.forEach((entry) => {
          entry.retry.addEventListener('click', () => handleUpload(entry));
        });

        Promise.allSettled(uploadableEntries.map((entry) => handleUpload(entry)));
        fileInput.value = '';
      });
    });
  </script>
)}

<style>
  .photo-page {
    background-color: var(--neutral-light);
    padding: 6rem 2rem 5rem;
  }

  .photo-page-content {
    max-width: 720px;
    margin: 0 auto;
    text-align: center;
  }

  .back-link {
    display: inline-block;
    font-family: 'Inter', 'Helvetica Neue', sans-serif;
    font-size: 0.95rem;
    color: var(--primary);
    text-decoration: none;
    margin-bottom: 2.5rem;
  }

  .back-link:hover {
    opacity: 0.8;
  }

  .photo-title {
    font-family: 'Cormorant Garamond', 'Georgia', serif;
    font-size: clamp(2rem, 6vw, 3.25rem);
    font-weight: 400;
    color: var(--neutral-dark);
    margin: 0 0 1.5rem 0;
    letter-spacing: 0.02em;
  }

  .photo-description {
    font-family: 'Inter', 'Helvetica Neue', sans-serif;
    font-size: 1.1rem;
    line-height: 1.7;
    color: var(--neutral-dark);
    opacity: 0.78;
    margin: 0 0 3rem 0;
  }

  .upload-card {
    padding: 2.5rem;
    border-radius: 16px;
    background-color: var(--neutral-light);
    box-shadow: 0 20px 50px rgba(45, 45, 45, 0.08);
  }

  .upload-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-family: 'Inter', 'Helvetica Neue', sans-serif;
    font-size: 1rem;
    font-weight: 500;
    color: var(--neutral-light);
    background-color: var(--primary);
    padding: 1rem 2.75rem;
    border-radius: 999px;
    cursor: pointer;
  }

  .upload-button:hover {
    opacity: 0.9;
  }

  .upload-input {
    position: absolute;
    opacity: 0;
    pointer-events: none;
  }

  .upload-hint {
    font-family: 'Inter', 'Helvetica Neue', sans-serif;
    font-size: 0.95rem;
    color: var(--neutral-dark);
    opacity: 0.6;
    margin: 1.5rem 0 0 0;
  }

  .upload-list {
    margin-top: 2rem;
    display: grid;
    gap: 1.25rem;
    text-align: left;
  }

  .upload-item {
    border-radius: 14px;
    padding: 1rem 1.25rem;
    border: 1px solid rgba(45, 45, 45, 0.08);
    background-color: var(--neutral-light);
  }

  .upload-item-header {
    display: flex;
    justify-content: space-between;
    gap: 1rem;
    font-family: 'Inter', 'Helvetica Neue', sans-serif;
    font-size: 0.95rem;
    color: var(--neutral-dark);
  }

  .upload-item-name {
    font-weight: 500;
  }

  .upload-item-status {
    opacity: 0.6;
  }

  .upload-item-status.success {
    color: var(--accent);
    opacity: 0.9;
  }

  .upload-item-status.error {
    color: var(--primary);
    opacity: 0.9;
  }

  .upload-progress {
    margin-top: 0.75rem;
    height: 6px;
    border-radius: 999px;
    background-color: rgba(45, 45, 45, 0.08);
    overflow: hidden;
  }

  .upload-progress-bar {
    height: 100%;
    width: 0%;
    background-color: var(--accent);
    transition: width 0.2s ease;
  }

  .upload-retry {
    margin-top: 0.75rem;
    font-family: 'Inter', 'Helvetica Neue', sans-serif;
    font-size: 0.9rem;
    background: none;
    border: none;
    color: var(--primary);
    cursor: pointer;
    padding: 0;
  }

  .upload-retry.hidden {
    display: none;
  }

  .upload-note {
    font-family: 'Inter', 'Helvetica Neue', sans-serif;
    font-size: 0.95rem;
    color: var(--neutral-dark);
    opacity: 0.6;
    margin: 1.5rem 0 0 0;
  }

  .upload-note.error {
    color: var(--primary);
    opacity: 0.9;
  }

  .photo-disabled {
    font-family: 'Inter', 'Helvetica Neue', sans-serif;
    font-size: 1rem;
    color: var(--neutral-dark);
    opacity: 0.75;
    padding: 2rem;
    border-radius: 16px;
    background-color: var(--neutral-light);
    box-shadow: 0 20px 50px rgba(45, 45, 45, 0.08);
  }

  @media (max-width: 640px) {
    .upload-card {
      padding: 2rem 1.5rem;
    }
  }

  .language-selector-container {
    position: fixed;
    top: 1rem;
    right: 1rem;
    z-index: 50;
  }

  @media (max-width: 640px) {
    .language-selector-container {
      top: 0.75rem;
      right: 0.75rem;
    }
  }
</style>

<script define:vars={{ slug }}>
  /**
   * Check for stored language preference on page load
   * If guest has a preference different from current URL, redirect
   */
  (function() {
    try {
      const storedLang = localStorage.getItem(`everbloom_language_${slug}`);
      const urlParams = new URLSearchParams(window.location.search);
      const urlLang = urlParams.get('lang');

      // If there's a stored preference and it's not already in the URL, redirect
      if (storedLang && storedLang !== urlLang) {
        urlParams.set('lang', storedLang);
        const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
        // Use replace to avoid adding to history
        window.location.replace(newUrl);
      }
    } catch {
      // localStorage might not be available
    }
  })();
</script>
