import { c as createComponent, a as createAstro, r as renderTemplate, g as defineScriptVars, f as renderComponent, m as maybeRenderHead, b as addAttribute } from '../../../chunks/astro/server_6gLzEsed.mjs';
import { a as fetchSiteConfig } from '../../../chunks/api_DY9V-Yw_.mjs';
import { g as getTranslations, $ as $$LanguageSelector } from '../../../chunks/LanguageSelector_BxXQ46vK.mjs';
import { a as $$PasscodeGateWrapper, $ as $$ErrorPage, b as $$WeddingLayout } from '../../../chunks/ErrorPage_Cw19BkIb.mjs';
/* empty css                                        */
export { renderers } from '../../../renderers.mjs';

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a, _b;
const $$Astro = createAstro();
const $$Photos = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Photos;
  const { slug } = Astro2.params;
  if (!slug) {
    return Astro2.redirect("/");
  }
  let config = null;
  let fetchError = false;
  try {
    config = await fetchSiteConfig(slug);
  } catch (error) {
    fetchError = true;
  }
  const showError = !config || fetchError;
  const errorType = fetchError ? "unavailable" : "not-found";
  const urlLang = Astro2.url.searchParams.get("lang");
  const adminLanguage = config?.language || "en";
  const effectiveLanguage = urlLang || adminLanguage;
  const t = getTranslations(effectiveLanguage);
  const photoEnabled = config?.features?.PHOTO_UPLOAD ?? false;
  config ? `${config.wedding.partnerNames[0]} & ${config.wedding.partnerNames[1]}` : "";
  const weddingSlug = config?.wedding.slug ?? "";
  const theme = config?.theme ?? { primary: "#c9826b", accent: "#8fac8b", neutralLight: "#faf8f5", neutralDark: "#2d2d2d" };
  return renderTemplate(_b || (_b = __template(["", "", "", "<script>(function(){", "\n  /**\n   * Check for stored language preference on page load\n   * If guest has a preference different from current URL, redirect\n   */\n  (function() {\n    try {\n      const storedLang = localStorage.getItem(`everbloom_language_${slug}`);\n      const urlParams = new URLSearchParams(window.location.search);\n      const urlLang = urlParams.get('lang');\n\n      // If there's a stored preference and it's not already in the URL, redirect\n      if (storedLang && storedLang !== urlLang) {\n        urlParams.set('lang', storedLang);\n        const newUrl = `${window.location.pathname}?${urlParams.toString()}`;\n        // Use replace to avoid adding to history\n        window.location.replace(newUrl);\n      }\n    } catch {\n      // localStorage might not be available\n    }\n  })();\n})();</script>"], ["", "", "", "<script>(function(){", "\n  /**\n   * Check for stored language preference on page load\n   * If guest has a preference different from current URL, redirect\n   */\n  (function() {\n    try {\n      const storedLang = localStorage.getItem(\\`everbloom_language_\\${slug}\\`);\n      const urlParams = new URLSearchParams(window.location.search);\n      const urlLang = urlParams.get('lang');\n\n      // If there's a stored preference and it's not already in the URL, redirect\n      if (storedLang && storedLang !== urlLang) {\n        urlParams.set('lang', storedLang);\n        const newUrl = \\`\\${window.location.pathname}?\\${urlParams.toString()}\\`;\n        // Use replace to avoid adding to history\n        window.location.replace(newUrl);\n      }\n    } catch {\n      // localStorage might not be available\n    }\n  })();\n})();</script>"])), showError && renderTemplate`${renderComponent($$result, "ErrorPage", $$ErrorPage, { "type": errorType, "data-astro-cid-qlnkyk3h": true })}`, !showError && config && renderTemplate`${renderComponent($$result, "PasscodeGateWrapper", $$PasscodeGateWrapper, { "config": config, "data-astro-cid-qlnkyk3h": true }, { "default": async ($$result2) => renderTemplate`${renderComponent($$result2, "WeddingLayout", $$WeddingLayout, { "config": config, "language": effectiveLanguage, "data-astro-cid-qlnkyk3h": true }, { "default": async ($$result3) => renderTemplate`${maybeRenderHead()}<div class="language-selector-container" data-astro-cid-qlnkyk3h>${renderComponent($$result3, "LanguageSelector", $$LanguageSelector, { "currentLanguage": effectiveLanguage, "slug": slug, "data-astro-cid-qlnkyk3h": true })}</div><section class="photo-page"${addAttribute(`--primary: ${theme.primary}; --accent: ${theme.accent}; --neutral-light: ${theme.neutralLight}; --neutral-dark: ${theme.neutralDark};`, "style")} data-astro-cid-qlnkyk3h><div class="photo-page-content" data-astro-cid-qlnkyk3h><a${addAttribute(`/w/${weddingSlug}${effectiveLanguage !== adminLanguage ? `?lang=${effectiveLanguage}` : ""}`, "href")} class="back-link" data-astro-cid-qlnkyk3h>${t.back}</a><h1 class="photo-title" data-astro-cid-qlnkyk3h>${t.photosTitle}</h1><p class="photo-description" data-astro-cid-qlnkyk3h>${t.photosDescription}</p>${photoEnabled ? renderTemplate`<div class="upload-card" id="upload" data-astro-cid-qlnkyk3h><label class="upload-button" for="photo-files" data-astro-cid-qlnkyk3h>${t.photosUploadButton}</label><input id="photo-files" class="upload-input" type="file" multiple accept="image/*" data-astro-cid-qlnkyk3h><p class="upload-hint" data-astro-cid-qlnkyk3h>${t.photosDragDrop}${t.photosBrowseButton}</p><div class="upload-list" id="upload-list" aria-live="polite" data-astro-cid-qlnkyk3h></div><p class="upload-note" id="upload-note" data-astro-cid-qlnkyk3h></p></div>` : renderTemplate`<div class="photo-disabled" data-astro-cid-qlnkyk3h>
Photo sharing is currently closed for this event.
</div>`}</div></section>` })}` })}`, !showError && photoEnabled && renderTemplate(_a || (_a = __template(["<script>(function(){", "\n    document.addEventListener('DOMContentLoaded', () => {\n      const fileInput = document.getElementById('photo-files');\n      const uploadList = document.getElementById('upload-list');\n      const uploadNote = document.getElementById('upload-note');\n\n      if (!fileInput || !uploadList || !uploadNote) {\n        return;\n      }\n\n      const maxFileSizeBytes = 10 * 1024 * 1024;\n      const maxFileSizeLabel = '10 MB';\n\n      const setNote = (message, tone) => {\n        uploadNote.textContent = message;\n        uploadNote.className = `upload-note${tone ? ` ${tone}` : ''}`;\n      };\n\n      const clearNote = () => {\n        uploadNote.textContent = '';\n        uploadNote.className = 'upload-note';\n      };\n\n      const createUploadItem = (file) => {\n        const item = document.createElement('div');\n        item.className = 'upload-item';\n\n        const header = document.createElement('div');\n        header.className = 'upload-item-header';\n\n        const name = document.createElement('span');\n        name.className = 'upload-item-name';\n        name.textContent = file.name;\n\n        const status = document.createElement('span');\n        status.className = 'upload-item-status';\n        status.textContent = 'Waiting';\n\n        header.appendChild(name);\n        header.appendChild(status);\n\n        const progress = document.createElement('div');\n        progress.className = 'upload-progress';\n\n        const progressBar = document.createElement('div');\n        progressBar.className = 'upload-progress-bar';\n        progress.appendChild(progressBar);\n\n        const retry = document.createElement('button');\n        retry.type = 'button';\n        retry.className = 'upload-retry hidden';\n        retry.textContent = 'Retry upload';\n\n        item.appendChild(header);\n        item.appendChild(progress);\n        item.appendChild(retry);\n        uploadList.appendChild(item);\n\n        return { item, status, progressBar, retry, file };\n      };\n\n      const setStatus = (entry, text, tone) => {\n        entry.status.textContent = text;\n        entry.status.className = `upload-item-status${tone ? ` ${tone}` : ''}`;\n      };\n\n      const updateProgress = (entry, percent) => {\n        const value = Math.max(0, Math.min(100, percent));\n        entry.progressBar.style.width = `${value}%`;\n      };\n\n      const requestUploadUrl = async (file) => {\n        const response = await fetch(`${apiBaseUrl}/photos/upload-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            slug: weddingSlug,\n            fileName: file.name,\n            contentType: file.type || 'application/octet-stream',\n            fileSize: file.size,\n          }),\n        });\n\n        const result = await response.json();\n        if (!result.ok) {\n          throw new Error(result.error || 'UPLOAD_FAILED');\n        }\n\n        return result.data.uploadUrl;\n      };\n\n      const uploadFile = (file, uploadUrl, onProgress) =>\n        new Promise((resolve, reject) => {\n          const xhr = new XMLHttpRequest();\n          xhr.open('POST', uploadUrl);\n\n          xhr.upload.addEventListener('progress', (event) => {\n            if (event.lengthComputable) {\n              onProgress(Math.round((event.loaded / event.total) * 100));\n            }\n          });\n\n          xhr.addEventListener('load', () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n              resolve();\n            } else {\n              reject(new Error('UPLOAD_FAILED'));\n            }\n          });\n\n          xhr.addEventListener('error', () => {\n            reject(new Error('NETWORK_ERROR'));\n          });\n\n          const formData = new FormData();\n          formData.append('file', file);\n          xhr.send(formData);\n        });\n\n      const handleUpload = async (entry) => {\n        entry.retry.classList.add('hidden');\n        setStatus(entry, 'Preparing upload', 'pending');\n        updateProgress(entry, 0);\n\n        try {\n          const uploadUrl = await requestUploadUrl(entry.file);\n          setStatus(entry, 'Uploading', 'pending');\n          await uploadFile(entry.file, uploadUrl, (percent) => updateProgress(entry, percent));\n          setStatus(entry, 'Uploaded', 'success');\n          updateProgress(entry, 100);\n        } catch (error) {\n          setStatus(entry, 'Upload failed', 'error');\n          entry.retry.classList.remove('hidden');\n        }\n      };\n\n      fileInput.addEventListener('change', () => {\n        const files = Array.from(fileInput.files || []);\n\n        uploadList.innerHTML = '';\n        clearNote();\n\n        if (!files.length) {\n          return;\n        }\n\n        const entries = files.map((file) => createUploadItem(file));\n        const oversized = entries.filter((entry) => entry.file.size > maxFileSizeBytes);\n        const invalidType = entries.filter((entry) => !entry.file.type.startsWith('image/'));\n\n        oversized.forEach((entry) => {\n          setStatus(entry, 'File is too large', 'error');\n          entry.retry.classList.add('hidden');\n        });\n\n        invalidType.forEach((entry) => {\n          setStatus(entry, 'Unsupported file type', 'error');\n          entry.retry.classList.add('hidden');\n        });\n\n        const uploadableEntries = entries.filter(\n          (entry) =>\n            entry.file.size <= maxFileSizeBytes && entry.file.type.startsWith('image/'),\n        );\n\n        const notes = [];\n        if (oversized.length) {\n          notes.push(`Some files were larger than ${maxFileSizeLabel} and were skipped.`);\n        }\n        if (invalidType.length) {\n          notes.push('Only image files can be uploaded.');\n        }\n        if (notes.length) {\n          setNote(notes.join(' '), 'error');\n        }\n\n        uploadableEntries.forEach((entry) => {\n          entry.retry.addEventListener('click', () => handleUpload(entry));\n        });\n\n        Promise.allSettled(uploadableEntries.map((entry) => handleUpload(entry)));\n        fileInput.value = '';\n      });\n    });\n  })();</script>"], ["<script>(function(){", "\n    document.addEventListener('DOMContentLoaded', () => {\n      const fileInput = document.getElementById('photo-files');\n      const uploadList = document.getElementById('upload-list');\n      const uploadNote = document.getElementById('upload-note');\n\n      if (!fileInput || !uploadList || !uploadNote) {\n        return;\n      }\n\n      const maxFileSizeBytes = 10 * 1024 * 1024;\n      const maxFileSizeLabel = '10 MB';\n\n      const setNote = (message, tone) => {\n        uploadNote.textContent = message;\n        uploadNote.className = \\`upload-note\\${tone ? \\` \\${tone}\\` : ''}\\`;\n      };\n\n      const clearNote = () => {\n        uploadNote.textContent = '';\n        uploadNote.className = 'upload-note';\n      };\n\n      const createUploadItem = (file) => {\n        const item = document.createElement('div');\n        item.className = 'upload-item';\n\n        const header = document.createElement('div');\n        header.className = 'upload-item-header';\n\n        const name = document.createElement('span');\n        name.className = 'upload-item-name';\n        name.textContent = file.name;\n\n        const status = document.createElement('span');\n        status.className = 'upload-item-status';\n        status.textContent = 'Waiting';\n\n        header.appendChild(name);\n        header.appendChild(status);\n\n        const progress = document.createElement('div');\n        progress.className = 'upload-progress';\n\n        const progressBar = document.createElement('div');\n        progressBar.className = 'upload-progress-bar';\n        progress.appendChild(progressBar);\n\n        const retry = document.createElement('button');\n        retry.type = 'button';\n        retry.className = 'upload-retry hidden';\n        retry.textContent = 'Retry upload';\n\n        item.appendChild(header);\n        item.appendChild(progress);\n        item.appendChild(retry);\n        uploadList.appendChild(item);\n\n        return { item, status, progressBar, retry, file };\n      };\n\n      const setStatus = (entry, text, tone) => {\n        entry.status.textContent = text;\n        entry.status.className = \\`upload-item-status\\${tone ? \\` \\${tone}\\` : ''}\\`;\n      };\n\n      const updateProgress = (entry, percent) => {\n        const value = Math.max(0, Math.min(100, percent));\n        entry.progressBar.style.width = \\`\\${value}%\\`;\n      };\n\n      const requestUploadUrl = async (file) => {\n        const response = await fetch(\\`\\${apiBaseUrl}/photos/upload-url\\`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            slug: weddingSlug,\n            fileName: file.name,\n            contentType: file.type || 'application/octet-stream',\n            fileSize: file.size,\n          }),\n        });\n\n        const result = await response.json();\n        if (!result.ok) {\n          throw new Error(result.error || 'UPLOAD_FAILED');\n        }\n\n        return result.data.uploadUrl;\n      };\n\n      const uploadFile = (file, uploadUrl, onProgress) =>\n        new Promise((resolve, reject) => {\n          const xhr = new XMLHttpRequest();\n          xhr.open('POST', uploadUrl);\n\n          xhr.upload.addEventListener('progress', (event) => {\n            if (event.lengthComputable) {\n              onProgress(Math.round((event.loaded / event.total) * 100));\n            }\n          });\n\n          xhr.addEventListener('load', () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n              resolve();\n            } else {\n              reject(new Error('UPLOAD_FAILED'));\n            }\n          });\n\n          xhr.addEventListener('error', () => {\n            reject(new Error('NETWORK_ERROR'));\n          });\n\n          const formData = new FormData();\n          formData.append('file', file);\n          xhr.send(formData);\n        });\n\n      const handleUpload = async (entry) => {\n        entry.retry.classList.add('hidden');\n        setStatus(entry, 'Preparing upload', 'pending');\n        updateProgress(entry, 0);\n\n        try {\n          const uploadUrl = await requestUploadUrl(entry.file);\n          setStatus(entry, 'Uploading', 'pending');\n          await uploadFile(entry.file, uploadUrl, (percent) => updateProgress(entry, percent));\n          setStatus(entry, 'Uploaded', 'success');\n          updateProgress(entry, 100);\n        } catch (error) {\n          setStatus(entry, 'Upload failed', 'error');\n          entry.retry.classList.remove('hidden');\n        }\n      };\n\n      fileInput.addEventListener('change', () => {\n        const files = Array.from(fileInput.files || []);\n\n        uploadList.innerHTML = '';\n        clearNote();\n\n        if (!files.length) {\n          return;\n        }\n\n        const entries = files.map((file) => createUploadItem(file));\n        const oversized = entries.filter((entry) => entry.file.size > maxFileSizeBytes);\n        const invalidType = entries.filter((entry) => !entry.file.type.startsWith('image/'));\n\n        oversized.forEach((entry) => {\n          setStatus(entry, 'File is too large', 'error');\n          entry.retry.classList.add('hidden');\n        });\n\n        invalidType.forEach((entry) => {\n          setStatus(entry, 'Unsupported file type', 'error');\n          entry.retry.classList.add('hidden');\n        });\n\n        const uploadableEntries = entries.filter(\n          (entry) =>\n            entry.file.size <= maxFileSizeBytes && entry.file.type.startsWith('image/'),\n        );\n\n        const notes = [];\n        if (oversized.length) {\n          notes.push(\\`Some files were larger than \\${maxFileSizeLabel} and were skipped.\\`);\n        }\n        if (invalidType.length) {\n          notes.push('Only image files can be uploaded.');\n        }\n        if (notes.length) {\n          setNote(notes.join(' '), 'error');\n        }\n\n        uploadableEntries.forEach((entry) => {\n          entry.retry.addEventListener('click', () => handleUpload(entry));\n        });\n\n        Promise.allSettled(uploadableEntries.map((entry) => handleUpload(entry)));\n        fileInput.value = '';\n      });\n    });\n  })();</script>"])), defineScriptVars({ apiBaseUrl: "http://localhost:3001/api", weddingSlug })), defineScriptVars({ slug }));
}, "/Users/batu/Documents/DEVELOPMENT/wedding-bestie/apps/wedding-site/src/pages/w/[slug]/photos.astro", void 0);
const $$file = "/Users/batu/Documents/DEVELOPMENT/wedding-bestie/apps/wedding-site/src/pages/w/[slug]/photos.astro";
const $$url = "/w/[slug]/photos";

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$Photos,
  file: $$file,
  url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

const page = () => _page;

export { page };
