## Progress Log

### 2026-01-06 - Initial Monorepo Setup and Dashboard Empty State

**Feature worked on:** Admin dashboard loads with no wedding selected (PRD: platform category)

**Priority rationale:** This is the foundational feature - without the monorepo structure and platform-ui, nothing else can be built. The dashboard empty state is the first user-facing feature after infrastructure.

**What was done:**
1. Created monorepo infrastructure:
   - root package.json with workspace scripts
   - pnpm-workspace.yaml
   - root tsconfig.json with project references
   - .gitignore

2. Created packages/shared with:
   - Core types: FeatureFlag, TemplateCategory, Theme, RenderConfig
   - API response types
   - Error codes (FEATURE_DISABLED, INVALID_TOKEN)

3. Created apps/platform-ui with:
   - Vite + React setup
   - TanStack Router and Query integration
   - Tailwind CSS with design system tokens (no pure black/white, curated palette)
   - Dashboard component with empty state
   - Layout component with minimal navigation

4. Created services/platform-api with:
   - NestJS scaffold
   - Health endpoint
   - CORS configured for dev

5. Created services/worker and apps/wedding-site stubs

**Design system adherence:**
- Colors use curated warm palette (primary: terracotta, accent: sage)
- No pure #000000 or #FFFFFF
- Typography: serif for headings, sans for body
- Minimal, calm UI with intentional whitespace
- Human language in microcopy ("Welcome to Everbloom", not "No records found")

**Next steps:**
- Run `pnpm install` to install dependencies
- Run `pnpm typecheck` and `pnpm test` to verify
- Implement magic link auth (prerequisite for full dashboard feature)
- Implement Stripe billing flow

**Notes for next person:**
- The dashboard shows an empty state that prompts creation/selection of weddings
- Auth is not yet implemented, so "Log in as admin" step cannot pass yet
- Feature "Admin dashboard loads with no wedding selected" depends on auth feature
- PRD should NOT be marked as passing until auth is in place and verified

---

### 2026-01-06 - Magic Link Authentication

**Feature worked on:** Admin can log in via magic link (PRD: platform category)

**Priority rationale:** This is the highest-priority feature because it unblocks:
1. The dashboard feature (which depends on "Log in as admin" step)
2. All platform features that require authentication
3. Admin-only actions like creating weddings, managing guests, etc.

**What was done:**
1. Fixed NestJS API to use `/api` prefix (was missing, frontend was calling `/api/auth/*` but backend was at `/auth/*`)

2. Added workspace dependency wiring:
   - Added `@wedding-bestie/shared` as dependency to platform-api and platform-ui
   - Built shared package to generate dist/ with types

3. Fixed TypeScript configuration issues:
   - Added `@types/node` and `types: ["node"]` to worker service
   - Excluded astro.config.mjs from wedding-site typecheck

4. Fixed test configuration:
   - Added `--passWithNoTests` to platform-api jest command

**Existing auth implementation (already present, now wired up):**
- Login page (Login.tsx): Email input form, sends POST to `/api/auth/request-link`
- VerifyMagicLink page: Handles `/auth/verify?token=...` callback
- AuthProvider (auth.tsx): Manages session state, stores token in localStorage
- AuthController: `/auth/request-link`, `/auth/verify-link`, `/auth/me`, `/auth/logout`
- AuthService: In-memory token/session storage (dev mode), logs magic link to console
- Routes (__root.tsx): Protected routes redirect to `/login`, login redirects if authenticated

**PRD features now passing:**
- "Admin can log in via magic link" âœ“
- "Admin dashboard loads with no wedding selected" âœ“ (was blocked by auth, now works)

**Next steps:**
- Implement Stripe billing flow (checkout session creation)
- Implement wedding provisioning on checkout.session.completed webhook
- Generate render_config on wedding creation

**Notes for next person:**
- In dev mode, magic links are logged to console (look for "ðŸ” MAGIC LINK" in platform-api output)
- Sessions are stored in-memory (restart API = logout all users)
- Run `pnpm dev` to start both UI and API together
- To test: enter email on login page, copy magic link from API console, paste in browser

---

### 2026-01-06 - Stripe Checkout Session Creation

**Feature worked on:** Stripe checkout session can be created for a new wedding (PRD: billing category)

**Priority rationale:** This is the next critical feature after auth because:
1. It enables the billing flow - couples can't create weddings without paying
2. It unblocks all downstream features (wedding provisioning, render_config, site rendering)
3. It's the gateway to all wedding-specific functionality

**What was done:**
1. Added Stripe SDK to platform-api:
   - Added `stripe` and `@nestjs/config` dependencies
   - Created BillingModule with controller and service

2. Created billing types in shared package:
   - `PlanTier` (starter | premium)
   - `Plan` interface with id, name, priceId, features
   - `CreateCheckoutSessionRequest` and `CreateCheckoutSessionResponse`
   - `CHECKOUT_SESSION_FAILED` error code

3. Implemented BillingService:
   - `getPlans()` - returns available plans with features
   - `createCheckoutSession()` - creates Stripe checkout session with wedding metadata

4. Implemented BillingController:
   - `GET /api/billing/plans` - public endpoint to get plans
   - `POST /api/billing/checkout-session` - authenticated endpoint to start checkout

5. Created UI flow for wedding creation:
   - CreateWedding component with 2-step form
   - Step 1: Enter wedding name and partner names
   - Step 2: Select plan (Starter or Premium)
   - Redirects to Stripe Checkout on submit

6. Created billing result pages:
   - BillingSuccess: Confirmation page with redirect to dashboard
   - BillingCancel: Friendly cancel page with return option

7. Updated Dashboard to integrate CreateWedding:
   - "Create your wedding site" button now triggers the creation flow
   - Added routes for /billing/success and /billing/cancel

**API Endpoints:**
- `GET /api/billing/plans` - Get available plans (public)
- `POST /api/billing/checkout-session` - Create checkout session (requires auth)
  - Request: `{ planId, weddingName, partnerNames }`
  - Response: `{ checkoutUrl, sessionId }`

**Design system adherence:**
- Step indicator with calm transitions
- Plan cards with clear feature lists
- Human language: "Tell us about your wedding", "Your wedding site is being created"
- No pure black/white colors
- Minimal, focused forms

**PRD features now passing:**
- "Stripe checkout session can be created for a new wedding" âœ“

**Next steps:**
- Implement Stripe webhook handler for checkout.session.completed
- Provision wedding record on successful payment
- Generate render_config on wedding creation
- Set up Stripe test prices for local development

**Notes for next person:**
- Stripe uses test mode by default (set STRIPE_SECRET_KEY for production)
- Plans use placeholder price IDs (price_starter_test, price_premium_test)
- Set STRIPE_PRICE_STARTER and STRIPE_PRICE_PREMIUM env vars for real prices
- Wedding metadata (name, partners) is stored in checkout session metadata
- The checkout.session.completed webhook will read this metadata to create the wedding

---

### 2026-01-06 - Stripe Webhook and Wedding Provisioning

**Feature worked on:** Successful Stripe checkout provisions a wedding (PRD: billing category)

**Priority rationale:** This is the critical next step after checkout session creation because:
1. Without webhook handling, users can pay but no wedding is created
2. Blocks all downstream features (render_config generation, site rendering, guest management)
3. This is the gateway between payment and actual product delivery

**What was done:**
1. Added Wedding types to shared package:
   - `Wedding` interface with id, userId, slug, name, partnerNames, planId, status, features
   - `CreateWeddingPayload` for provisioning from checkout metadata
   - `WeddingProvisionResponse` for webhook response
   - `WEBHOOK_SIGNATURE_INVALID` error code

2. Created WeddingService (services/platform-api/src/wedding/):
   - In-memory storage for weddings and render_configs (dev mode)
   - `generateSlug()` - creates URL-safe slug from partner names with random suffix
   - `buildFeatureFlags()` - enables features based on plan tier (starter vs premium)
   - `generateRenderConfig()` - creates initial render_config with default template and sections
   - `provisionWedding()` - idempotent wedding creation from checkout completion
   - Session tracking for idempotency (prevents duplicate weddings on webhook replay)

3. Created WeddingModule and wired to BillingModule

4. Added Stripe webhook handler to BillingController:
   - `POST /api/billing/stripe-webhook` endpoint
   - Signature verification using Stripe SDK
   - Handles `checkout.session.completed` event
   - Extracts wedding metadata from session
   - Calls WeddingService.provisionWedding()
   - Returns wedding and render_config on success

5. Updated main.ts to enable raw body parsing for webhook signature verification

**Feature flags by plan:**
- Starter: RSVP, CALENDAR_INVITE
- Premium: All flags (RSVP, CALENDAR_INVITE, PHOTO_UPLOAD, ANNOUNCEMENT_BANNER, FAQ_SECTION, PASSCODE_SITE)

**Default theme:**
- Primary: #c9826b (terracotta)
- Accent: #8fac8b (sage)
- Neutral Light: #faf8f5 (warm off-white)
- Neutral Dark: #2d2d2d (soft black)

**API Endpoints:**
- `POST /api/billing/stripe-webhook` - Stripe webhook handler
  - Requires `stripe-signature` header
  - Requires raw body for signature verification
  - Handles `checkout.session.completed` to provision weddings
  - Idempotent - same session ID will not create duplicate weddings

**PRD features now passing:**
- "Successful Stripe checkout provisions a wedding" âœ“

**Next steps:**
- Note: "Wedding site render_config is generated on provisioning" is already implemented as part of this feature
- Next feature should be wedding site rendering from render_config
- Or implement feature toggle UI in admin dashboard

**Notes for next person:**
- In dev mode, weddings and render_configs are stored in-memory (restart API = lose data)
- Webhook requires `STRIPE_WEBHOOK_SECRET` env var for production
- For local testing, use Stripe CLI: `stripe listen --forward-to localhost:3001/api/billing/stripe-webhook`
- Slugs are generated as `partner1-and-partner2-{random}` (URL-safe, lowercase)
- The render_config generation is already in place - provisioning feature passes

---

### 2026-01-06 - Wedding render_config API Endpoint

**Feature worked on:** Wedding site render_config is generated on provisioning (PRD: provisioning category)

**Priority rationale:** This was the highest-priority incomplete feature because:
1. The render_config generation logic was already implemented in WeddingService
2. However, there was no API endpoint to fetch the render_config
3. This blocks the wedding site rendering feature (which needs to consume render_config)
4. Without an endpoint, the PRD step "Fetch wedding_sites.render_config" could not pass

**What was done:**
1. Created WeddingController (services/platform-api/src/wedding/wedding.controller.ts):
   - `GET /api/weddings` - List all weddings for authenticated user
   - `GET /api/weddings/:id` - Get a specific wedding by ID
   - `GET /api/weddings/:id/render-config` - Fetch render_config for a wedding
   - All endpoints require authentication and verify ownership

2. Updated WeddingModule to:
   - Import AuthModule (using forwardRef to avoid circular dependency)
   - Register WeddingController

3. Updated AppModule to:
   - Import WeddingModule directly (previously only imported via BillingModule)

**API Endpoints added:**
- `GET /api/weddings` - Returns user's weddings array
- `GET /api/weddings/:id` - Returns wedding details
- `GET /api/weddings/:id/render-config` - Returns the render_config object containing:
  - `templateId` (e.g., "minimal-001")
  - `theme` (primary, accent, neutralLight, neutralDark)
  - `features` (feature flags record based on plan)
  - `sections` (array of section definitions)
  - `wedding` (slug, partnerNames)

**PRD features now passing:**
- "Wedding site render_config is generated on provisioning" âœ“

**Next steps:**
- Implement wedding site rendering from render_config (site category)
- This will require updating the Astro wedding site to fetch and render from the config

**Notes for next person:**
- The render_config is stored in-memory alongside weddings (dev mode)
- Endpoint requires Bearer token authentication
- Only the wedding owner can fetch their render_config
- The config contains all data needed for the wedding site to render without additional DB queries

---

### 2026-01-06 - Wedding Site Renders from render_config

**Feature worked on:** Wedding site renders exclusively from render_config (PRD: site category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. It completes the provisioningâ†’rendering pipeline
2. It unblocks all guest-facing features (RSVP, photos, announcements)
3. Without a rendered wedding site, none of the other guest-facing features can be tested
4. It demonstrates the core architecture: platform provisions, site renders

**What was done:**
1. Added public endpoint for wedding site config:
   - `GET /api/site-config/:slug` - No auth required, wedding slug is the identifier
   - Created SiteConfigController (services/platform-api/src/wedding/site-config.controller.ts)
   - Returns render_config for active weddings only

2. Added shared package dependency to wedding-site:
   - Added `@wedding-bestie/shared` workspace dependency for types

3. Created API client for fetching site config:
   - `apps/wedding-site/src/lib/api.ts`
   - `fetchSiteConfig(slug)` - single fetch for all rendering data

4. Created Astro components for wedding site rendering:
   - `WeddingLayout.astro` - Base layout with theme CSS variables and fonts
   - `SectionRenderer.astro` - Maps section types to components, respects feature flags
   - `HeroSection.astro` - Hero section with partner names headline
   - `EventDetailsSection.astro` - Event details with date, venue, city
   - `RsvpSection.astro` - RSVP CTA section (only renders if RSVP feature enabled)

5. Created dynamic route `/w/[slug]`:
   - `apps/wedding-site/src/pages/w/[slug].astro`
   - Fetches render_config via single API call (no database joins)
   - Returns 404 if wedding not found or inactive

**Architecture adherence:**
- Wedding site renders EXCLUSIVELY from render_config (no direct DB queries)
- Single data fetch per page load
- Feature flags respected (RSVP section only shows if feature enabled)
- Theme CSS variables set from render_config theme
- No joins, no multi-table queries

**Design system adherence:**
- Typography: Cormorant Garamond (serif) for headings, Inter (sans) for body
- Colors: Theme-driven via CSS variables (no hardcoded colors)
- No pure black (#000000) or pure white (#FFFFFF)
- Generous whitespace, calm visual style
- Mobile-first responsive design

**API Endpoints added:**
- `GET /api/site-config/:slug` - Public endpoint for wedding site rendering
  - Returns render_config with template, theme, features, sections, wedding info
  - No authentication required
  - Returns 404 for non-existent or inactive weddings

**PRD features now passing:**
- "Wedding site renders exclusively from render_config" âœ“

**Next steps:**
- Implement template switching feature in admin dashboard
- Or implement guest-facing RSVP flow
- Consider adding announcement banner rendering

**Notes for next person:**
- Wedding sites are at `/w/{slug}` (e.g., `/w/john-and-jane-abc123`)
- The site fetches config from platform-api at startup
- Set `PUBLIC_PLATFORM_API_URL` env var for production deployment
- In dev, defaults to `http://localhost:3001/api`
- To test: create a wedding via Stripe checkout, then visit `/w/{slug}`

---

### 2026-01-06 - Admin Can Add Invitees Manually

**Feature worked on:** Admin can add invitees manually (PRD: guests category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. It's the foundation for all guest management features
2. Without guests, RSVP and invitation features cannot function
3. It completes the core admin workflow: login â†’ create wedding â†’ add guests
4. It unblocks downstream features: CSV import, sending invites, RSVP tracking

**What was done:**
1. Added Guest types to shared package:
   - `RsvpStatus` type ('pending' | 'attending' | 'not_attending')
   - `Guest` interface with all guest fields (id, weddingId, name, email, partySize, rsvpStatus, etc.)
   - `CreateGuestRequest` and `UpdateGuestRequest` for API calls
   - `GuestListResponse` for list endpoint
   - Error codes: `GUEST_NOT_FOUND`, `GUEST_ALREADY_EXISTS`, `WEDDING_NOT_FOUND`

2. Created GuestService (services/platform-api/src/guest/guest.service.ts):
   - In-memory storage for development
   - `createGuest()` - creates new guest with RSVP token, checks for duplicate emails
   - `updateGuest()` - updates guest details
   - `deleteGuest()` - removes guest
   - `getGuest()` / `getGuestsForWedding()` - retrieval methods
   - `getGuestSummary()` - aggregates RSVP counts

3. Created GuestController (services/platform-api/src/guest/guest.controller.ts):
   - `GET /api/weddings/:weddingId/guests` - list all guests
   - `POST /api/weddings/:weddingId/guests` - create guest
   - `GET /api/weddings/:weddingId/guests/:guestId` - get single guest
   - `PUT /api/weddings/:weddingId/guests/:guestId` - update guest
   - `DELETE /api/weddings/:weddingId/guests/:guestId` - delete guest
   - All endpoints require authentication and verify wedding ownership

4. Created GuestModule and registered in AppModule

5. Created Guests page component (apps/platform-ui/src/components/Guests.tsx):
   - List view with guest cards showing name, email, RSVP status
   - Add guest form with name and email inputs
   - Delete functionality with confirmation
   - Empty state with friendly messaging
   - Loading states

6. Updated Dashboard component:
   - Now fetches weddings from API on mount
   - Auto-selects first wedding if only one exists
   - Shows wedding selection when multiple weddings
   - WeddingDashboard view with navigation cards
   - "Your guests" card navigates to Guests page
   - "Your site" card links to wedding site

**API Endpoints:**
- `GET /api/weddings/:weddingId/guests` - List guests (requires auth)
- `POST /api/weddings/:weddingId/guests` - Create guest (requires auth)
- `GET /api/weddings/:weddingId/guests/:guestId` - Get guest (requires auth)
- `PUT /api/weddings/:weddingId/guests/:guestId` - Update guest (requires auth)
- `DELETE /api/weddings/:weddingId/guests/:guestId` - Delete guest (requires auth)

**Design system adherence:**
- Calm, minimal UI with intentional whitespace
- Human language: "Your guests", "Add your first guest", "No guests yet"
- RSVP status badges with muted colors
- No pure black/white colors
- Large, clear form inputs

**PRD features now passing:**
- "Admin can add invitees manually" âœ“

**Next steps:**
- Implement CSV import for bulk guest adding
- Implement invitation sending
- Implement guest-facing RSVP flow

**Notes for next person:**
- Guests are stored in-memory (restart API = lose data)
- Each guest gets a unique RSVP token on creation (32 bytes, hex encoded)
- Duplicate email check is per-wedding (same email can be in different weddings)
- Dashboard auto-selects first wedding if user has only one
- Guest list is sorted alphabetically by name

---

### 2026-01-06 - Guest RSVP Flow (View, Submit, Edit)

**Feature worked on:** Guest can view RSVP form via tokenized link (PRD: rsvp category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. Guests are the core users of the wedding site
2. RSVP is the primary guest interaction for most weddings
3. We already have guests with tokens from the admin add feature
4. It unlocks the guest-facing value of the platform
5. It's foundational for invitation sending (next feature)

**What was done:**
1. Added RSVP types to shared package:
   - `RsvpGuestView` - guest data subset for RSVP (excludes sensitive fields like token)
   - `RsvpWeddingView` - minimal wedding info for RSVP display
   - `RsvpViewData` - combined response with guest, wedding, and theme
   - `RsvpSubmitRequest` - submission payload with token, status, partySize, dietaryNotes
   - `RsvpSubmitResponse` - confirmation message and updated guest data

2. Added guest token lookup to GuestService:
   - `getGuestByRsvpToken(token)` - finds guest by RSVP token
   - `updateRsvpStatus(guestId, status, partySize, dietaryNotes)` - updates RSVP response

3. Created RsvpController (services/platform-api/src/rsvp/):
   - `GET /api/rsvp/view?token=...` - Fetches guest data for RSVP form
     - Validates token exists and is valid
     - Checks wedding is active
     - Checks RSVP feature is enabled
     - Returns deterministic errors: INVALID_TOKEN, FEATURE_DISABLED, WEDDING_NOT_FOUND
   - `POST /api/rsvp/submit` - Submits/updates RSVP response
     - Same validation as view endpoint
     - Updates guest's RSVP status, party size, dietary notes
     - Sets rsvpSubmittedAt timestamp
     - Returns confirmation message

4. Created RsvpModule and registered in AppModule

5. Updated wedding-site API client:
   - Added `fetchRsvpView(token)` function
   - Added `submitRsvp(request)` function

6. Created RSVP page (apps/wedding-site/src/pages/rsvp/index.astro):
   - Route: `/rsvp?token=...`
   - Mobile-first responsive design
   - Large tap targets for RSVP options
   - Stepper control for party size (not tiny input)
   - Optional dietary notes (below the fold)
   - Shows previous response if guest already RSVP'd
   - Success confirmation with celebratory message
   - Error handling with friendly messages

**API Endpoints:**
- `GET /api/rsvp/view?token=...` - Public endpoint for RSVP form data
  - Returns: guest info, wedding details, theme
  - Errors: INVALID_TOKEN, FEATURE_DISABLED, WEDDING_NOT_FOUND
- `POST /api/rsvp/submit` - Public endpoint for RSVP submission
  - Request: { token, rsvpStatus, partySize, dietaryNotes? }
  - Returns: confirmation message, updated guest data

**Design system adherence:**
- Mobile-first with large 48px tap targets
- One-question-per-block layout (status â†’ party size â†’ dietary)
- Calm, celebratory language ("Joyfully accept", "We can't wait to celebrate with you")
- Stepper control for party size (not tiny input)
- Theme colors from wedding's render_config
- No pure black/white colors
- Serif headings (Cormorant Garamond), sans body (Inter)

**PRD features now passing:**
- "Guest can view RSVP form via tokenized link" âœ“
- "Guest can submit RSVP" âœ“
- "Guest can edit RSVP using same link" âœ“

**Next steps:**
- Implement admin RSVP summary dashboard
- Implement invitation email sending
- Implement CSV import for bulk guest adding

**Notes for next person:**
- RSVP link format: `/rsvp?token={64-char-hex-token}`
- Tokens are stored as plain text in dev mode (production should hash)
- Re-visiting RSVP link shows previous response and allows changes
- Dietary notes are optional and hidden until "Attending" is selected
- Party size stepper has min=1, max=20
- Error messages use human language (not technical codes)
- The RsvpSection on wedding site links to /w/{slug}/rsvp which doesn't exist yet (future: request RSVP link page)

---

### 2026-01-06 - Admin RSVP Summary Dashboard

**Feature worked on:** Admin can view RSVP summary (PRD: dashboard category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. RSVP features for guests are complete (view, submit, edit)
2. Admin needs visibility into RSVP status to manage their wedding
3. It's core dashboard functionality - admin must know who's coming
4. Simple to implement since GuestService already has getGuestSummary()
5. Completes the admin's wedding management workflow

**What was done:**
1. Added RSVP summary types to shared package:
   - `RsvpSummary` interface with total, attending, notAttending, pending, totalPartySize
   - `RsvpSummaryResponse` combining summary with guest list

2. Added summary API endpoint to GuestController:
   - `GET /api/weddings/:weddingId/guests/summary` - authenticated endpoint
   - Returns RSVP counts and full guest list for the wedding
   - Reuses existing GuestService.getGuestSummary() method

3. Created RsvpDashboard component (apps/platform-ui/src/components/RsvpDashboard.tsx):
   - Summary cards showing: Attending (with total party size), Not attending, Awaiting response, Total invited
   - Guest list grouped by RSVP status (attending, not attending, pending)
   - Shows party size and dietary notes for attending guests
   - Shows RSVP submission date when available
   - Empty state with friendly messaging
   - Loading state with spinner

4. Updated Dashboard component:
   - Added "RSVP responses" card in WeddingDashboard
   - Added navigation to RsvpDashboard view
   - Added ClipboardIcon for the new card

**API Endpoints:**
- `GET /api/weddings/:weddingId/guests/summary` - Get RSVP summary (requires auth)
  - Returns: { summary: RsvpSummary, guests: Guest[] }
  - Summary includes: total, attending, notAttending, pending, totalPartySize

**Design system adherence:**
- Summary cards with calm colors (accent for attending, neutral for others)
- Guest lists grouped by status with clear section headers
- Human language: "Awaiting response" not "Pending", "Track who's coming" not "View RSVPs"
- No pure black/white colors
- Minimal, scannable layout

**PRD features now passing:**
- "Admin can view RSVP summary" âœ“

**Next steps:**
- Implement CSV import for bulk guest adding
- Implement invitation email sending
- Implement photo upload feature

**Notes for next person:**
- RSVP summary is available at /api/weddings/:weddingId/guests/summary
- Dashboard now has 3 cards: Your guests, RSVP responses, Your site
- Guests are grouped by RSVP status in the dashboard for easy scanning
- totalPartySize counts only attending guests' party sizes

---

### 2026-01-06 - CSV Import for Guests

**Feature worked on:** Admin can import invitees via CSV (PRD: guests category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. Most weddings have 50-200+ guests - manual entry is impractical
2. It's a natural extension of the existing guest management infrastructure
3. It doesn't require new infrastructure (unlike photos which needs storage, or emails which needs SendGrid)
4. It unblocks bulk guest workflows and makes the platform production-ready for real weddings

**What was done:**
1. Added CSV import types to shared package:
   - `CsvGuestRow` - a single row from CSV (name, email, partySize)
   - `CsvImportRowResult` - result per row with success/error status
   - `CsvImportRequest` - request body containing guest rows
   - `CsvImportResponse` - response with imported/skipped counts and results
   - `CSV_IMPORT_VALIDATION_ERROR` error code

2. Added bulk import method to GuestService:
   - `importGuestsFromCsv(weddingId, rows)` - processes CSV rows
   - Validates each row (name required, email required, email format)
   - Checks for duplicate emails within the wedding
   - Returns detailed results per row
   - Made `findByEmail` method public for duplicate checking

3. Added CSV import endpoint to GuestController:
   - `POST /api/weddings/:weddingId/guests/import` - authenticated endpoint
   - Validates request has guests array
   - Limits import size to 500 guests per request
   - Returns detailed results with imported/skipped counts

4. Added CSV import UI to Guests page:
   - Multi-step import flow: Upload â†’ Map columns â†’ Confirm â†’ Results
   - CSV file parsing with quote handling
   - Auto-detection of name/email/partySize columns from headers
   - Column mapping UI with dropdowns
   - Preview of first 5 rows with mapped data
   - Import confirmation step
   - Results summary showing imported/skipped counts
   - Detailed skipped rows table with error reasons

**API Endpoints:**
- `POST /api/weddings/:weddingId/guests/import` - Bulk import guests (requires auth)
  - Request: `{ guests: CsvGuestRow[] }`
  - Response: `{ imported, skipped, total, results: CsvImportRowResult[] }`
  - Max 500 guests per request

**Design system adherence:**
- Multi-step wizard with clear progress indicator
- Drag-and-drop upload zone with file picker fallback
- Clean preview table for column mapping verification
- Summary cards for import results (imported/skipped)
- Human language: "Import guests from CSV", "Map columns", "Guests with invalid data..."
- No pure black/white colors
- Calm, minimal UI

**PRD features now passing:**
- "Admin can import invitees via CSV" âœ“

**Next steps:**
- Implement invitation email sending
- Implement photo upload feature
- Implement announcement banner feature

**Notes for next person:**
- CSV import endpoint is at POST /api/weddings/:weddingId/guests/import
- Maximum 500 guests per import to prevent timeout
- CSV parser handles quoted fields (e.g., "Smith, John")
- Column auto-detection looks for "name", "email", "party"/"size"/"guests" in headers
- Duplicate emails within the same wedding are skipped
- Import results include per-row error details for debugging
- The import form maintains step state and shows results before closing

---

### 2026-01-06 - Admin Can Send Invitation Emails

**Feature worked on:** Admin can send invitation emails (PRD: invites category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. The entire RSVP flow is complete (guests can view/submit/edit RSVP)
2. But there's no way to actually SEND the RSVP links to guests
3. Without invitation sending, the guest management features are incomplete
4. It completes the core guest workflow: add guests â†’ send invites â†’ guests RSVP

**What was done:**
1. Added invitation/email types to shared package:
   - `EmailStatus` type ('pending' | 'sent' | 'failed')
   - `EmailType` type ('invitation' | 'reminder' | 'update')
   - `EmailOutbox` interface for tracking sent emails
   - `SendInvitationsRequest`, `SendInvitationResult`, `SendInvitationsResponse`
   - `EMAIL_SEND_FAILED`, `NO_GUESTS_SELECTED` error codes

2. Created EmailService (services/platform-api/src/invitation/email.service.ts):
   - `buildInvitationEmail(guest, wedding)` - generates personalized HTML/text email content
   - `sendEmail(content)` - sends via SendGrid API in production, logs in development
   - Beautiful, branded email template with RSVP link
   - Development mode: logs email to console instead of actually sending

3. Created InvitationService (services/platform-api/src/invitation/invitation.service.ts):
   - In-memory email_outbox storage for development
   - `createOutboxRecord()` - tracks email attempts
   - `updateOutboxStatus()` - updates status on send success/failure
   - `sendInvitations(weddingId, guestIds)` - batch sends invitations
   - `getOutboxForWedding()` / `getOutboxForGuest()` - retrieval methods

4. Created InvitationController (services/platform-api/src/invitation/invitation.controller.ts):
   - `POST /api/weddings/:weddingId/invitations/send` - send invitations to selected guests
   - `GET /api/weddings/:weddingId/invitations/outbox` - get email history
   - All endpoints require authentication and verify wedding ownership

5. Created InvitationModule and registered in AppModule

6. Updated Guests page component (apps/platform-ui/src/components/Guests.tsx):
   - Added guest selection with checkboxes
   - Added "Select all" / "Deselect all" functionality
   - Added "Send invites" button that appears when guests are selected
   - Created SendInvitesDialog component:
     - Confirmation view showing selected guests
     - Sends invitation via API
     - Results view showing sent/failed counts
     - Error handling with friendly messages

**API Endpoints:**
- `POST /api/weddings/:weddingId/invitations/send` - Send invitations (requires auth)
  - Request: `{ guestIds: string[] }`
  - Response: `{ sent, failed, total, results: SendInvitationResult[] }`
- `GET /api/weddings/:weddingId/invitations/outbox` - Get email outbox (requires auth)
  - Response: `{ emails: EmailOutbox[] }`

**Design system adherence:**
- Checkbox selection with primary color fill
- Modal dialog for send confirmation
- Clear summary cards for sent/failed counts
- Human language: "Send invitations", "Invitations sent", "Sent successfully"
- No pure black/white colors
- Calm, minimal UI with branded email template

**PRD features now passing:**
- "Admin can send invitation emails" âœ“

**Next steps:**
- Implement photo upload feature
- Implement announcement banner feature
- Implement reminder emails via worker queue

**Notes for next person:**
- In dev mode, emails are logged to console (look for "ðŸ“§ DEVELOPMENT MODE" in platform-api output)
- In production, set SENDGRID_API_KEY, SENDGRID_FROM_EMAIL, SENDGRID_FROM_NAME env vars
- Set WEDDING_SITE_URL env var for RSVP links in emails (defaults to http://localhost:4321)
- Email outbox tracks all sends with status (pending/sent/failed)
- The invitation email includes a personalized RSVP link with the guest's token
- To test: add guests â†’ select them â†’ click "Send invites" â†’ check API console for logged emails

---

### 2026-01-06 - Template Switching Without Content Loss

**Feature worked on:** Template can be switched without losing content (PRD: site category)

**Priority rationale:** This is a high-priority feature because:
1. Template switching is core to the product value proposition
2. The render_config architecture already supports it conceptually
3. It completes the wedding site customization workflow
4. It allows couples to explore different visual styles before their wedding

**What was done:**
1. Added template types to shared package:
   - `Template` interface with id, name, category, description, defaultTheme
   - `ChangeTemplateRequest` and `ChangeTemplateResponse` types
   - `TemplatesListResponse` for listing available templates
   - `TEMPLATE_NOT_FOUND` error code

2. Added template definitions in WeddingService:
   - 5 curated templates across categories (Minimal, Classic, Modern, Destination)
   - Serene (minimal-001): Clean lines and generous whitespace
   - Whisper (minimal-002): Soft tones and delicate typography
   - Heritage (classic-001): Timeless design with traditional flourishes
   - Edge (modern-001): Bold typography and contemporary layouts
   - Wanderlust (destination-001): Travel-inspired design

3. Added template methods to WeddingService:
   - `getTemplates()` - returns all available templates
   - `getTemplate(id)` - returns a single template by ID
   - `changeTemplate(weddingId, templateId)` - changes template while preserving content
   - Content preservation: sections data remains intact, only templateId and theme change

4. Added API endpoints to WeddingController:
   - `GET /api/weddings/templates/list` - List all available templates (public)
   - `PUT /api/weddings/:id/template` - Change wedding template (requires auth)

5. Created TemplateSelector component (apps/platform-ui/src/components/TemplateSelector.tsx):
   - Template grid with visual previews using theme colors
   - Shows current template with "Current" badge
   - Color swatch preview for selected template
   - Save/Cancel buttons with loading states
   - Success message on template change

6. Updated Dashboard component:
   - Added "Site template" card with palette icon
   - Added template view navigation
   - Created TemplateSelectorWrapper to fetch current template
   - PaletteIcon component for the dashboard card

**API Endpoints:**
- `GET /api/weddings/templates/list` - Get all available templates (public)
  - Returns: `{ templates: Template[] }`
- `PUT /api/weddings/:id/template` - Change wedding template (requires auth)
  - Request: `{ templateId: string }`
  - Response: `{ renderConfig: RenderConfig }`
  - Content (sections) is preserved, only visual style changes

**Design system adherence:**
- Curated palette of 5 templates across categories (not arbitrary selection)
- Template previews show actual theme colors
- No pure black/white in any template theme
- Human language: "Choose your visual style", "Your content will be preserved"
- Calm, minimal UI with clear selection states

**PRD features now passing:**
- "Template can be switched without losing content" âœ“

**Next steps:**
- Implement feature selection step during wedding setup
- Implement feature toggle UI in admin dashboard
- Implement photo upload feature
- Implement announcement banner feature

**Notes for next person:**
- Templates are defined in WeddingService as TEMPLATES constant
- Each template has a defaultTheme that is applied when switching
- Content (sections array) is preserved during template switch
- Template list endpoint is public, change endpoint requires auth
- The wedding site renders from render_config which includes templateId
- To test: create wedding â†’ go to dashboard â†’ click "Site template" â†’ select new template â†’ save â†’ view site

---

### 2026-01-06 - Admin Can Disable RSVP Feature

**Feature worked on:** Disabling RSVP hides RSVP on public site + Disabling RSVP blocks RSVP API endpoints (PRD: features category)

**Priority rationale:** This is a high-priority feature because:
1. Feature flags are foundational to the product architecture
2. The feature flag infrastructure already existed but admins couldn't toggle them
3. Without this, users can't customize which features are active on their site
4. It validates the end-to-end feature flag flow: admin toggles â†’ site renders â†’ API blocks

**What was done:**
1. Added feature toggle types to shared package:
   - `UpdateFeaturesRequest` - partial feature flag updates
   - `UpdateFeaturesResponse` - returns updated wedding and render_config

2. Added `updateFeatures` method to WeddingService:
   - Updates wedding.features record
   - Regenerates render_config with updated features
   - Updates section enabled states based on feature flags (e.g., RSVP section disabled when RSVP flag is false)

3. Added API endpoint to WeddingController:
   - `PUT /api/weddings/:id/features` - authenticated endpoint to toggle features
   - Validates ownership and updates feature flags
   - Returns updated wedding and render_config

4. Created FeatureSettings component (apps/platform-ui/src/components/FeatureSettings.tsx):
   - Feature toggle UI with on/off switches for each flag
   - Shows feature descriptions in human language
   - Indicates which features require Premium plan
   - Disables unavailable features based on plan tier
   - Save/Cancel buttons with loading states

5. Updated Dashboard component:
   - Added "Site features" card to WeddingDashboard
   - Added features view navigation
   - Added ToggleIcon for the dashboard card

**How feature disabling works (already implemented, now toggleable):**
- Wedding site: `SectionRenderer.astro` checks `features.RSVP` before rendering RSVP section
- RSVP page: Shows "RSVPs are currently closed for this event." when feature disabled
- RSVP API: Both `/api/rsvp/view` and `/api/rsvp/submit` return `FEATURE_DISABLED` error

**API Endpoints:**
- `PUT /api/weddings/:id/features` - Update feature flags (requires auth)
  - Request: `{ features: { RSVP: boolean, PHOTO_UPLOAD: boolean, ... } }`
  - Response: `{ wedding: Wedding, renderConfig: RenderConfig }`

**Design system adherence:**
- Toggle switches with primary color when enabled
- Feature descriptions in human language
- Premium features shown but disabled with plan indicator
- Calm, minimal UI with clear save/cancel actions
- No pure black/white colors

**PRD features now passing:**
- "Disabling RSVP hides RSVP on public site" âœ“
- "Disabling RSVP blocks RSVP API endpoints" âœ“

**Next steps:**
- Implement feature selection step during wedding setup
- Implement photo upload feature
- Implement announcement banner feature

**Notes for next person:**
- Feature toggles are at PUT /api/weddings/:id/features
- Dashboard has a new "Site features" card to access settings
- Starter plan only allows RSVP and CALENDAR_INVITE toggles
- Premium plan allows all 6 feature toggles
- When RSVP is disabled, the render_config is updated with features.RSVP=false AND sections[rsvp].enabled=false
- The wedding site reads features from render_config, so changes are immediate
- To test: create wedding â†’ dashboard â†’ "Site features" â†’ toggle RSVP off â†’ save â†’ visit wedding site â†’ RSVP section should be gone

### 2026-01-07 - Feature Selection Applied During Wedding Setup

**Feature worked on:** Feature selection step available during wedding setup (PRD: features category)

**Priority rationale:** This ensures the feature selection step during wedding creation is not just cosmetic by persisting the chosen toggles into provisioning. It aligns the setup flow with the per-wedding feature flag architecture and keeps the initial render_config accurate.

**What was done:**
1. Applied feature selections during provisioning:
   - WeddingService now accepts an optional feature selection payload
   - Features are filtered by plan tier and default to enabled when not explicitly set

2. Wired Stripe webhook metadata into provisioning:
   - Parsed feature selections from checkout session metadata
   - Passed normalized flags into wedding provisioning

**PRD features now passing:**
- "Feature selection step available during wedding setup" âœ“

**Notes for next person:**
- Feature selection is stored in Stripe checkout metadata as JSON
- Provisioning now respects selected toggles while still enforcing plan eligibility
- If no feature selection is provided, plan defaults still enable all allowed features

---

### 2026-01-07 - Admin Can Create Announcement Banner

**Feature worked on:** Admin can create announcement banner (PRD: announcements category)

**Priority rationale:** Announcement banners are a lightweight, high-visibility way for couples to share updates. This feature is simpler than photo uploads or reminders, and it completes the admin-side content workflow needed before public display.

**What was done:**
1. Added announcement types and API contracts to shared package:
   - Wedding records now store optional announcement content
   - Added UpdateAnnouncementRequest/Response types

2. Added announcement storage in platform API:
   - WeddingService stores announcement data on the wedding record
   - render_config now includes announcement data
   - New updateAnnouncement method updates wedding + render_config

3. Added announcement update endpoint:
   - PUT /api/weddings/:id/announcement (auth required)
   - Enforces FEATURE_DISABLED when announcement banner is not enabled
   - Validates title/message when enabled

4. Added admin UI for announcement settings:
   - New AnnouncementSettings view with enable toggle, title, and message
   - Dashboard card shown only when ANNOUNCEMENT_BANNER feature is enabled
   - Calm, minimal form styling with friendly validation

**PRD features now passing:**
- "Admin can create announcement banner" âœ“

**Notes for next person:**
- Announcement content lives on the Wedding record and in render_config
- Admin UI fetches current announcement from /api/weddings/:id/render-config
- Announcement settings are only accessible when ANNOUNCEMENT_BANNER is enabled
- Public site rendering of the announcement banner is still pending

---

### 2026-01-07 - Announcement Banner Display on Wedding Site

**Feature worked on:** Announcement banner displays on public site (PRD: announcements category)

**Priority rationale:** This completes the end-to-end announcement flow (admin create -> public display) and is a lightweight change that brings guest-facing visibility to updates.

**What was done:**
1. Added an AnnouncementBanner component to render announcement title/message with theme styling.
2. Updated the /w/[slug] page to show the banner when ANNOUNCEMENT_BANNER is enabled and announcement.enabled is true.
3. Ensured the banner appears above all site sections so it reads as a true top-of-page notice.

**PRD features now passing:**
- "Announcement banner displays on public site" âœ“

**Next steps:**
- Implement photo upload feature (enable, upload, metadata)
- Implement reminder emails via worker queue

**Notes for next person:**
- Banner rendering lives in apps/wedding-site/src/components/AnnouncementBanner.astro
- Display gating checks both the feature flag and announcement.enabled

---

### 2026-01-07 - Photo Upload CTA + Page

**Feature worked on:** Photo upload feature can be enabled (PRD: photos category)

**Priority rationale:** Photo uploads are the next major guest-facing feature; enabling the CTA and route is the prerequisite for the full signed-URL upload flow.

**What was done:**
1. Added a photo-upload section to initial render_config and ensured feature toggles update its enabled state.
2. Added a PhotoUploadSection component and wired SectionRenderer to render it when PHOTO_UPLOAD is enabled.
3. Restructured the /w/[slug] route into a folder to support /w/[slug]/photos and created the photo page with feature gating and calm UI copy.

**PRD features now passing:**
- "Photo upload feature can be enabled" âœ“

**Notes for next person:**
- Wedding page moved to `apps/wedding-site/src/pages/w/[slug]/index.astro` to support nested routes.
- Photo page lives at `apps/wedding-site/src/pages/w/[slug]/photos.astro` and shows a friendly disabled message if PHOTO_UPLOAD is off.
- Upload UI is present but not wired to signed URL endpoints yet; next step is implementing actual upload + metadata storage.

---

### 2026-01-07 - Guest Photo Uploads via Signed URLs

**Feature worked on:** Guest can upload photos via signed URLs (PRD: photos category)

**Priority rationale:** Photo uploads are the next major guest-facing interaction after RSVP. Implementing signed uploads unblocks the real media flow while keeping the site render-only and secure.

**What was done:**
1. Added signed upload flow in platform-api:
   - New PhotosModule with `POST /api/photos/upload-url` and `POST /api/photos/upload/:uploadId`
   - HMAC-signed URLs with expiry, feature flag checks, and wedding status validation
   - Dev storage writes to `uploads/{weddingId}` with validation (image type + 10 MB max)

2. Added shared photo upload types + error codes

3. Wired wedding site photo page to:
   - Request signed URLs per file
   - Upload via multipart POST with per-file progress
   - Show retry for failed uploads and calm error messaging

4. Expanded API CORS allowlist for wedding site dev origins

**PRD features now passing:**
- "Guest can upload photos via signed URLs" âœ“

**Notes for next person:**
- Upload URLs expire after 10 minutes; max size is 10 MB per file
- Upload endpoint expects multipart form field `file`
- Files are stored under `uploads/{weddingId}` in dev (ignored by git)
- Photo metadata storage + admin photo list are still pending

### 2026-01-07 - Photo Metadata Stored + Admin List

**Feature worked on:** Uploaded photo metadata is stored (PRD: photos category)

**Priority rationale:** Photo uploads were working, but without stored metadata there was no admin visibility. This completes the photo flow by persisting upload details and exposing them in the platform UI.

**What was done:**
1. Added photo metadata types in the shared package for admin listing.
2. Stored photo records after upload in the platform API and added a list method.
3. Added an authenticated admin endpoint: `GET /api/weddings/:weddingId/photos` with feature flag gating.
4. Added a Photo uploads section to the Site features page with refresh, empty state, and list display.

**PRD features now passing:**
- "Uploaded photo metadata is stored" âœ“

**Notes for next person:**
- Photo metadata is stored in-memory alongside uploads (restart API clears it).
- Admin list is visible under Site features only when PHOTO_UPLOAD is enabled.
- Endpoint returns FEATURE_DISABLED if photo sharing is off.
- `plans/features.json` was not present when looking for the required pass flag update.

---

### 2026-01-07 - Reminder Emails via Worker Queue

**Feature worked on:** Reminder emails are sent via worker queue (PRD: email category)

**Priority rationale:** Reminder emails close the RSVP loop and are the last outstanding operational email feature. Implementing them via BullMQ validates the queue + worker architecture and keeps sending off the API request thread.

**What was done:**
1. Added reminder queue types and payload contracts to the shared package, including a queue name constant.
2. Added reminder enqueue flow in platform API:
   - New POST /api/weddings/:weddingId/invitations/reminders endpoint
   - ReminderQueueService to add BullMQ jobs
   - Outbox status update endpoint for worker callbacks
3. Added reminder email template in EmailService.
4. Implemented worker processor to send reminder emails and report results back to the platform API.

**PRD features now passing:**
- "Reminder emails are sent via worker queue" âœ“

**Notes for next person:**
- Queue name: `email-reminders` (BullMQ)
- Trigger reminders: POST `/api/weddings/:weddingId/invitations/reminders` (auth required)
- Worker status callback: POST `/api/weddings/:weddingId/invitations/outbox/:outboxId/status` with `x-worker-token` if set
- Reminders default to pending guests only (RSVP feature must be enabled)
- Worker uses `PLATFORM_API_URL` (default `http://localhost:3001/api`) and `WORKER_TOKEN` if configured

### 2026-01-07 - Template Categories Match Product Positioning

**Feature worked on:** Template categories exist and match product positioning (PRD: design category)

**Priority rationale:** This is the highest-priority remaining design item because template selection is a core positioning surface, and missing category coverage breaks the curated taxonomy promise.

**What was done:**
1. Added a Cultural template to the curated template list with a compliant theme.
2. Grouped templates by category in the admin selector with clear category headings and counts.
3. Displayed human-readable category labels on template cards.

**PRD features now passing:**
- "Template categories exist and match product positioning" âœ“

**Notes for next person:**
- Categories are ordered and labeled in TemplateSelector.
- Cultural template ID: cultural-001.
- plans/features.json not found when attempting to flip the required pass flag.

---

### 2026-01-07 - Curated Palette Enforcement

**Feature worked on:** Colors are restricted to curated palettes with accessibility-safe contrast (PRD: design category)

**Priority rationale:** Palette enforcement underpins the calm, ceremonial design system and prevents drift into arbitrary or high-contrast colors.

**What was done:**
1. Replaced pure white UI surfaces and controls in the platform UI with neutral token surfaces (neutral-50) for cards, toggles, checkboxes, and spinners.
2. Updated RSVP page styling to derive surfaces and borders from theme variables and removed hard-coded white/border hexes.
3. Updated invitation and reminder email templates to use off-white palette values and neutral borders/text (no #FFFFFF).

**PRD features now passing:**
- "Colors are restricted to curated palettes with accessibility-safe contrast" âœ“

**Notes for next person:**
- RSVP page now defines theme-derived surface and border variables (`--neutral-surface`, `--neutral-border`).
- Email templates use off-white card and button text colors (no pure white).
- Created `plans/features.json` by mirroring `prd.json` for ongoing pass tracking.

---

### 2026-01-07 - Secure RSVP Token Implementation

**Feature worked on:** RSVP tokens are cryptographically secure (PRD: security category)

**Priority rationale:** This is a critical security feature because:
1. The existing implementation stored RSVP tokens in plaintext
2. Token comparison used direct string equality (timing attack vulnerability)
3. Per CLAUDE.md: "Tokens are random (32+ bytes), stored hashed in DB; compare hashed only"
4. Security issues could expose guest data in a database breach

**What was done:**
1. Updated Guest type to use `rsvpTokenHash` instead of `rsvpToken`:
   - `services/platform-api/src/types/index.ts`: Guest interface now stores SHA-256 hash
   - `apps/platform-ui/src/types.ts`: Removed token field entirely (never exposed to UI)

2. Updated GuestService with secure token handling:
   - Added `hashToken(token)`: SHA-256 hash function
   - Added `verifyToken(candidate, storedHash)`: timing-safe comparison using `crypto.timingSafeEqual`
   - Updated `createGuest()`: Returns `{ guest, rawToken }` - hash stored, raw returned for email
   - Updated `getGuestByRsvpToken()`: Uses timing-safe hash comparison
   - Added `regenerateRsvpToken()`: Generates new token for sending invitations/reminders

3. Updated EmailService to accept raw token as parameter:
   - `buildInvitationEmail(guest, wedding, rawToken)`: Token passed explicitly
   - `buildReminderEmail(guest, wedding, rawToken)`: Token passed explicitly

4. Updated InvitationService to regenerate tokens on each email send:
   - `sendInvitations()`: Regenerates token before sending, invalidates old links
   - `enqueueReminders()`: Regenerates token before queuing reminder emails

5. Updated GuestController and CSV import to handle new return types.

**Security architecture:**
- Tokens are 32 bytes random (64-char hex string) - cryptographically secure
- Only SHA-256 hash is stored (`rsvpTokenHash`) - database breach doesn't expose raw tokens
- Timing-safe comparison via `crypto.timingSafeEqual` - prevents timing attacks
- Raw tokens only exist in memory during email sending - never persisted
- Token regeneration on each email send - old RSVP links are invalidated
- Invalid/malformed tokens return same `INVALID_TOKEN` error - no information leakage

**PRD features now passing:**
- "RSVP tokens are cryptographically secure" âœ“
- "Token validation uses constant-time comparison" âœ“
- "Invalid tokens return deterministic error" âœ“

**Notes for next person:**
- Raw token is only available at guest creation and during `regenerateRsvpToken()`
- When sending invitations/reminders, token is regenerated (old links stop working)
- Guest records returned to UI no longer include token (hash or raw)
- Token flow: generate â†’ hash for storage â†’ return raw for email â†’ discard raw
- The `rsvpTokenHash` field replaces the old `rsvpToken` field throughout the codebase

---

### 2026-01-07 - Calendar Invite Feature

**Feature worked on:** Calendar invite functionality (PRD: calendar category)

**Priority rationale:** Calendar invites are a core guest-facing feature that:
1. CALENDAR_INVITE was already a defined feature flag with no implementation
2. It's directly tied to the event details section (already rendering on wedding sites)
3. Allows guests to easily add the wedding to their personal calendars
4. Completes the event information workflow: admin sets details â†’ guests add to calendar

**What was done:**
1. Added calendar/event types to platform-api types:
   - `EventDetailsData` interface with date, startTime, endTime, venue, address, city, timezone
   - `UpdateEventDetailsRequest/Response` types
   - `CALENDAR_INVITE_DISABLED` and `EVENT_DETAILS_NOT_CONFIGURED` error codes

2. Extended Wedding and RenderConfig to include eventDetails:
   - Wedding record stores eventDetails
   - RenderConfig includes eventDetails and populates wedding.date/venue/city from it

3. Added event details management in WeddingService:
   - `updateEventDetails()` method to save event details and regenerate render_config

4. Added event details API endpoint:
   - `PUT /api/weddings/:id/event-details` (auth required)
   - Validates date format (YYYY-MM-DD) and time format (HH:MM)
   - All fields except timezone are required

5. Created CalendarController for public calendar endpoints:
   - `GET /api/calendar/:slug/download.ics` - ICS file download
   - `GET /api/calendar/:slug/google` - Redirect to Google Calendar with prefilled event
   - Both endpoints check CALENDAR_INVITE feature flag and event details existence
   - Returns FEATURE_DISABLED or EVENT_DETAILS_NOT_CONFIGURED as appropriate

6. Updated EventDetailsSection.astro with calendar buttons:
   - Shows "Add to Calendar" (ICS download) and "Google Calendar" buttons
   - Only visible when CALENDAR_INVITE feature enabled AND eventDetails configured
   - Displays formatted date/time from eventDetails
   - Mobile-responsive button layout

7. Updated SectionRenderer.astro to pass new props:
   - slug, calendarEnabled, eventDetails passed to EventDetailsSection

8. Created EventSettings admin component:
   - Form for date, start time, end time, venue, address, city, timezone
   - Timezone dropdown with common options
   - Validation before save
   - Success/error feedback

9. Added "Event details" card to Dashboard for navigation to EventSettings

**API Endpoints:**
- `PUT /api/weddings/:id/event-details` - Update event details (requires auth)
  - Request: `{ eventDetails: { date, startTime, endTime, venue, address, city, timezone? } }`
  - Response: `{ wedding, renderConfig }`
- `GET /api/calendar/:slug/download.ics` - Download ICS file (public, feature-gated)
- `GET /api/calendar/:slug/google` - Redirect to Google Calendar (public, feature-gated)

**Design system adherence:**
- Calendar buttons use theme colors (primary for ICS, transparent border for Google)
- Human language: "Add to Calendar", "Google Calendar"
- Mobile-first responsive layout
- Calm, minimal button styling with subtle hover effects
- Event details form uses clean, focused inputs

**PRD features now passing:**
- "Admin can configure event details for calendar invites" âœ“
- "Guest can download ICS calendar file" âœ“
- "Guest can add event to Google Calendar" âœ“
- "Calendar invite respects feature toggle" âœ“

**Notes for next person:**
- Calendar endpoints are at /api/calendar/{slug}/download.ics and /api/calendar/{slug}/google
- Event details are required for calendar buttons to appear (even with feature enabled)
- ICS file includes proper VCALENDAR/VEVENT structure with timezone support
- Google Calendar uses the /calendar/render URL with query params
- Event details admin UI accessible from dashboard "Event details" card
- Timezone is optional; defaults to UTC if not specified
- The calendar buttons only show when both conditions are met:
  1. CALENDAR_INVITE feature flag is enabled
  2. eventDetails are configured (via admin Event details page)

---

### 2026-01-07 - FAQ Feature Implementation

**Feature worked on:** FAQ section functionality (PRD: faq category)

**Priority rationale:** This is the highest-priority remaining feature because:
1. FAQ_SECTION is an existing feature flag with no implementation
2. It follows the same pattern as announcement banners (admin CRUD + public display)
3. It completes the content customization workflow for wedding sites
4. It's a common wedding site requirement that adds real user value

**What was done:**
1. Added FAQ types to platform-api types:
   - `FaqItem` interface with id, question, answer, order
   - `FaqConfig` interface with items array
   - `UpdateFaqRequest` and `UpdateFaqResponse` types
   - Extended Wedding and RenderConfig to include faq field

2. Added FAQ methods to WeddingService:
   - Default FAQ config (empty items array)
   - FAQ section creation in generateRenderConfig()
   - `updateFaq()` method for updating FAQ items
   - FAQ section enabled state updates in updateFeatures()

3. Added FAQ endpoint to WeddingController:
   - `PUT /api/weddings/:id/faq` - authenticated endpoint
   - Feature flag validation (FAQ_SECTION must be enabled)
   - Input validation (each item needs question and answer)
   - Normalizes items with IDs and order

4. Added FAQ types to platform-ui types:
   - FaqItem, FaqConfig interfaces
   - UpdateFaqResponse type

5. Created FaqSettings component:
   - Add new FAQ items with "Add your first question" / "Add another question" buttons
   - Edit question and answer for each item
   - Reorder items with up/down arrow buttons
   - Delete items with trash button
   - Disabled state when FAQ_SECTION feature is off
   - Save/cancel with loading states and success feedback

6. Updated Dashboard component:
   - Added FAQ card (conditionally shown when FAQ_SECTION enabled)
   - Added FAQ view handler and navigation
   - Added QuestionMarkIcon for the dashboard card

7. Added FAQ types to wedding-site:
   - FaqItem, FaqConfig interfaces
   - Extended RenderConfig with faq field

8. Created FaqSection.astro component:
   - Accordion-style FAQ display using HTML <details> elements
   - Theme-aware styling with CSS variables
   - Empty state message when no items
   - Mobile-responsive design
   - Serif headings, sans-serif body text

9. Updated SectionRenderer.astro:
   - Import FaqSection component
   - Handle 'faq' section type with FAQ_SECTION feature check
   - Pass faq config to FaqSection

**API Endpoints:**
- `PUT /api/weddings/:id/faq` - Update FAQ items (requires auth)
  - Request: `{ faq: { items: FaqItem[] } }`
  - Response: `{ wedding, renderConfig }`
  - Returns FEATURE_DISABLED if FAQ_SECTION is off

**Design system adherence:**
- Accordion FAQ with + icon that rotates on open
- Human language: "Frequently asked questions", "Answer common questions"
- No pure black/white colors - uses theme variables
- Serif headings (Cormorant Garamond), sans body (Inter)
- Mobile-first responsive design
- Calm transitions on hover and open/close

**PRD features now passing:**
- "Admin can add FAQ items" âœ“
- "Admin can edit and reorder FAQ items" âœ“
- "FAQ section renders on public site" âœ“
- "FAQ section respects feature toggle" âœ“

**Notes for next person:**
- FAQ endpoint is at PUT /api/weddings/:id/faq
- FAQ card only shows in dashboard when FAQ_SECTION feature is enabled
- FAQ items are stored on both Wedding record and in render_config
- FAQ section uses HTML <details> elements for native accordion behavior
- Empty state shown when no FAQ items exist
- FAQ section appears after photo-upload section (order 4) by default
- Reordering works via up/down buttons; order is persisted on save
- FAQ_SECTION is a premium-only feature (not available on starter plan)

---

### 2026-01-07 - Passcode Site Protection Feature

**Feature worked on:** Passcode site protection (PRD: passcode category)

**Priority rationale:** This is the highest-priority remaining feature because:
1. PASSCODE_SITE is an existing feature flag with no implementation
2. Privacy is increasingly important for couples who want private wedding sites
3. It's a complete end-to-end security feature (admin CRUD + guest verification + session persistence)
4. It follows the existing pattern but adds security considerations (hashing, timing-safe comparison)

**What was done:**
1. Added passcode types to platform-api types:
   - `PasscodeConfigBase` interface with enabled and passcodeHash fields
   - Extended Wedding interface with passcodeConfig field
   - Extended RenderConfig with passcodeProtected boolean (hash never exposed)
   - `UpdatePasscodeRequest` and `UpdatePasscodeResponse` types
   - `VerifyPasscodeRequest` and `VerifyPasscodeResponse` types
   - `INVALID_PASSCODE` and `PASSCODE_NOT_CONFIGURED` error codes

2. Implemented passcode storage and verification in WeddingService:
   - `hashPasscode()` function using Node's scrypt with random salt
   - `verifyPasscode()` function with timing-safe comparison to prevent timing attacks
   - `updatePasscode()` method for enabling/disabling protection and setting passcode
   - `verifyWeddingPasscode()` method for guest-facing verification
   - `isPasscodeRequired()` helper to check if a wedding requires passcode

3. Added passcode API endpoints:
   - `PUT /api/weddings/:id/passcode` - Admin endpoint to update passcode settings (auth required)
   - `POST /api/site-config/:slug/verify-passcode` - Public endpoint for guest verification
   - `GET /api/site-config/:slug/passcode-required` - Public endpoint to check if passcode needed

4. Added passcode types to platform-ui types:
   - `PasscodeConfig` interface (no hash, just enabled + hasPasscode flags)
   - `UpdatePasscodeResponse` type
   - Extended Wedding interface with passcodeConfig

5. Created PasscodeSettings component (platform-ui):
   - Enable/disable toggle for passcode protection
   - Password input with show/hide toggle
   - Confirm passcode field when setting new passcode
   - Minimum 4 character validation
   - Info box explaining how it works
   - Disabled state when PASSCODE_SITE feature is off
   - Success/error feedback

6. Updated Dashboard component:
   - Added 'passcode' to View type
   - Added PasscodeSettings import and view handler
   - Added onNavigateToPasscode prop
   - Added LockIcon component
   - Added "Site protection" card (conditionally shown when PASSCODE_SITE enabled)

7. Added passcode types to wedding-site types:
   - Extended RenderConfig with passcodeProtected field
   - Added VerifyPasscodeResponse type

8. Created PasscodeGateWrapper.astro component:
   - Checks if passcode protection is enabled from config
   - Shows passcode entry form if protected and no valid session
   - Stores session token in localStorage for returning visitors
   - Clean, themed UI matching wedding site design
   - Client-side JavaScript for form submission and session management

9. Updated wedding site pages to use PasscodeGateWrapper:
   - /w/[slug]/index.astro - Main wedding page
   - /w/[slug]/photos.astro - Photo upload page

**API Endpoints:**
- `PUT /api/weddings/:id/passcode` - Update passcode settings (requires auth)
  - Request: `{ enabled: boolean, passcode?: string }`
  - Response: `{ wedding, renderConfig }`
  - Returns FEATURE_DISABLED if PASSCODE_SITE is off
- `POST /api/site-config/:slug/verify-passcode` - Verify passcode (public)
  - Request: `{ passcode: string }`
  - Response: `{ valid: boolean, sessionToken?: string }`
- `GET /api/site-config/:slug/passcode-required` - Check if passcode needed (public)
  - Response: `{ required: boolean }`

**Security implementation:**
- Passcodes are hashed using scrypt with random 16-byte salt
- Format: `salt:hash` (both hex-encoded)
- Verification uses timing-safe comparison to prevent timing attacks
- Raw passcode is never stored, only the hash
- Session tokens are random 32-byte hex strings
- localStorage used for client-side session persistence

**Design system adherence:**
- Lock icon and themed colors for passcode gate
- Human language: "This wedding site is private", "Please enter the passcode"
- No pure black/white colors - uses theme variables
- Serif heading (Cormorant Garamond), sans body (Inter)
- Mobile-friendly form with centered layout
- Clear error states with friendly messages

**PRD features now passing:**
- "Admin can set site passcode" âœ“
- "Guests must enter passcode to view protected site" âœ“
- "Passcode session persists for returning visitors" âœ“

**Notes for next person:**
- Passcode endpoint is at PUT /api/weddings/:id/passcode
- Passcode card only shows in dashboard when PASSCODE_SITE feature is enabled
- PASSCODE_SITE is a premium-only feature (not available on starter plan)
- Session persistence uses localStorage with key `everbloom_passcode_{slug}`
- Clearing browser storage resets the session and requires re-entering passcode
- Both main wedding page and photos page are protected
- The passcode gate checks for existing session before showing form
- Passcode verification endpoint returns sessionToken for client storage
- PasscodeGateWrapper is a pure Astro component (no React dependency needed)

---

### 2026-01-07 - Hero Section Content Editing

**Feature worked on:** Admin can edit hero section content (PRD: content category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. Content editing is fundamental to the product - couples need to customize their wedding site
2. The hero section is the first thing guests see, making it essential for personalization
3. It follows the established patterns for other content editing features (announcements, FAQ, event details)
4. It was the first content-editing feature that was not yet implemented

**What was done:**
1. Added hero content types to platform-api types:
   - `HeroContentData` interface with headline and optional subheadline
   - `UpdateHeroContentRequest` and `UpdateHeroContentResponse` types

2. Added `updateHeroContent` method to WeddingService:
   - Updates the hero section data within render_config
   - Preserves other section data while updating headline/subheadline
   - Updates wedding timestamp

3. Added hero content API endpoint to WeddingController:
   - `PUT /api/weddings/:id/hero` - authenticated endpoint
   - Validates headline is required
   - Subheadline is optional
   - Returns updated wedding and renderConfig

4. Added hero content types to platform-ui types:
   - `HeroContentData` interface
   - `UpdateHeroContentResponse` type

5. Created HeroSettings component (apps/platform-ui/src/components/HeroSettings.tsx):
   - Fetches current hero content from render_config
   - Form fields for headline and optional subheadline
   - Live preview of how the hero section will look
   - Change detection (save button disabled when no changes)
   - Success/error feedback

6. Updated Dashboard component:
   - Added 'hero' to View type
   - Added HeroSettings import and view handler
   - Added onNavigateToHero prop to WeddingDashboard
   - Added SparklesIcon component
   - Added "Hero section" card as first item (since it's primary content editing)

7. Updated HeroSection.astro to render subheadline:
   - Added subheadline extraction from section data
   - Added conditional rendering of subheadline paragraph
   - Added styling for subheadline (Inter sans-serif, muted opacity)

**API Endpoints:**
- `PUT /api/weddings/:id/hero` - Update hero content (requires auth)
  - Request: `{ heroContent: { headline: string, subheadline?: string } }`
  - Response: `{ wedding, renderConfig }`

**Design system adherence:**
- Hero preview uses serif font (Cormorant Garamond) for headline
- Subheadline uses sans-serif (Inter) with muted opacity
- Human language: "Edit your site's headline", "Customize the headline that appears..."
- No pure black/white colors - uses theme variables
- Mobile-responsive preview styling

**PRD features now passing:**
- "Admin can edit hero section content" âœ“

**Notes for next person:**
- Hero endpoint is at PUT /api/weddings/:id/hero
- Hero section card is always visible in dashboard (not feature-gated)
- The headline is pre-populated with partner names from wedding record
- Subheadline is optional and can be left empty
- Changes are reflected immediately in render_config
- The hero section in wedding site now supports both headline and subheadline
- HeroSettings fetches current content from /api/weddings/:id/render-config
- Preview shows live typing feedback as user edits

---

### 2026-01-07 - Guest Tagging/Segmentation Feature

**Feature worked on:** Admin can create guest tags for segmentation + Admin can filter guests by tag (PRD: guests category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. Guest segmentation is foundational for targeted communications
2. It enables filtering guests by tag (bride's side, groom's side, etc.)
3. It's a prerequisite for sending invites to specific segments
4. It follows established patterns in the codebase (tag CRUD, guest association)

**What was done:**
1. Added tag types to platform-api types:
   - `GuestTag` interface with id, weddingId, name, color, createdAt
   - `CreateTagRequest` and `UpdateTagRequest` types
   - `TagListResponse` and `AssignTagsRequest` types
   - `TAG_NOT_FOUND` and `TAG_ALREADY_EXISTS` error codes
   - Updated `Guest` interface with optional `tagIds` array

2. Created TagService (services/platform-api/src/guest/tag.service.ts):
   - In-memory storage for tags
   - CRUD methods: createTag, updateTag, deleteTag, getTag
   - Retrieval: getTagsForWedding, findByName, tagBelongsToWedding
   - Default color palette aligned with design system

3. Added tag methods to GuestService:
   - `assignTagsToGuests(guestIds, tagIds)` - add tags to guests
   - `removeTagsFromGuests(guestIds, tagIds)` - remove tags from guests
   - `getGuestsByTags(weddingId, tagIds)` - filter guests by tags
   - `removeTagFromAllGuests(weddingId, tagId)` - cleanup when deleting tag

4. Created TagController (services/platform-api/src/guest/tag.controller.ts):
   - `GET /api/weddings/:weddingId/tags` - list all tags
   - `POST /api/weddings/:weddingId/tags` - create tag
   - `GET /api/weddings/:weddingId/tags/:tagId` - get single tag
   - `PUT /api/weddings/:weddingId/tags/:tagId` - update tag
   - `DELETE /api/weddings/:weddingId/tags/:tagId` - delete tag
   - `POST /api/weddings/:weddingId/tags/assign` - assign tags to guests
   - `POST /api/weddings/:weddingId/tags/unassign` - remove tags from guests
   - `GET /api/weddings/:weddingId/tags/filter/guests` - filter guests by tags

5. Updated GuestModule to include TagService and TagController

6. Added tag types to platform-ui types.ts:
   - GuestTag, TagListResponse, AssignTagsRequest interfaces
   - Updated Guest interface with tagIds

7. Updated Guests.tsx component with:
   - Tag state management (tags, filterTagIds, showTagManager, showAssignTags)
   - fetchTags function to load tags from API
   - Tag filter bar with clickable tag chips
   - Tag badges displayed on guest rows
   - TagManagerDialog component for creating/editing/deleting tags
   - AssignTagsDialog component for bulk tag assignment
   - TagIcon and XIcon components

**API Endpoints:**
- `GET /api/weddings/:weddingId/tags` - List all tags (requires auth)
- `POST /api/weddings/:weddingId/tags` - Create tag (requires auth)
- `GET /api/weddings/:weddingId/tags/:tagId` - Get single tag (requires auth)
- `PUT /api/weddings/:weddingId/tags/:tagId` - Update tag (requires auth)
- `DELETE /api/weddings/:weddingId/tags/:tagId` - Delete tag (requires auth)
- `POST /api/weddings/:weddingId/tags/assign` - Assign tags to guests (requires auth)
- `POST /api/weddings/:weddingId/tags/unassign` - Remove tags from guests (requires auth)
- `GET /api/weddings/:weddingId/tags/filter/guests` - Filter guests by tags (requires auth)

**Design system adherence:**
- Curated tag colors aligned with design system (sage, terracotta, dusty blue, lavender, etc.)
- Tag chips with rounded corners and muted backgrounds
- Human language: "Manage tags", "Assign tags", "Filter by tag"
- No pure black/white colors
- Minimal, calm UI with clear selection states

**PRD features now passing:**
- "Admin can create guest tags for segmentation" âœ“
- "Admin can filter guests by tag" âœ“

**Next steps:**
- Implement "Admin can send invites to specific segments" (uses tag filtering)
- Continue with other incomplete features

**Notes for next person:**
- Tags are stored in-memory (restart API = lose data)
- Default tag colors are curated from the design system palette
- Duplicate tag names within a wedding are prevented
- When a tag is deleted, it's automatically removed from all guests
- Tag filtering returns guests that have ANY of the selected tags (OR logic)
- Guest rows display tag badges next to their names
- Selected guests can have tags assigned in bulk via AssignTagsDialog

---

### 2026-01-07 - Send Invites to Specific Segments

**Feature worked on:** Admin can send invites to specific segments (PRD: guests category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. Guest tagging and filtering already existed
2. Invitation sending already existed
3. Only the UI wiring was incorrect - "Select all" selected ALL guests instead of filtered guests
4. This completes the guest segmentation workflow: tag â†’ filter â†’ select â†’ send
5. Very small code change with high user value

**What was done:**
1. Fixed `handleSelectAll` in Guests.tsx to only select visible (filtered) guests:
   - When filtered, clicking "Select all" now only selects guests matching the filter
   - Previously it selected ALL guests regardless of filter state
   - Uses `filterTagIds.length > 0` to detect filtered state

2. Fixed `GuestList` component checkbox state calculation:
   - Changed from comparing `selectedIds.size === guests.length` to counting actual visible selections
   - `visibleSelectedCount` correctly counts how many of the displayed guests are selected
   - "Deselect all" / "Select all" state and selected count now reflect visible guests only

3. Verified existing flow is correct:
   - `SendInvitesDialog` receives `filteredGuests.filter((g) => selectedGuestIds.has(g.id))`
   - This correctly filters to ONLY guests that are both visible AND selected
   - Invitation sending API and email_outbox already worked correctly

**User workflow now works:**
1. Admin creates tags (e.g., "Bride's side", "Groom's side")
2. Admin assigns tags to guests
3. Admin clicks tag filter (e.g., "Bride's side")
4. Admin clicks "Select all" - only visible guests selected
5. Admin clicks "Send invites" - only tagged guests receive invitations
6. Email_outbox records match exactly the filtered guest list

**PRD features now passing:**
- "Admin can send invites to specific segments" âœ“

**Next steps:**
- Implement "Admin can see invite delivery status"
- Continue with other incomplete features

**Notes for next person:**
- Selection state can persist across filter changes (intended behavior)
- When switching filters, previously selected guests remain selected but aren't visible
- Clicking "Select all" on new filter adds those guests to selection
- The send dialog shows only guests that are both selected AND visible
- This enables batch workflow: select bride's side, then select groom's side, send to both
