## Progress Log

### 2026-01-06 - Initial Monorepo Setup and Dashboard Empty State

**Feature worked on:** Admin dashboard loads with no wedding selected (PRD: platform category)

**Priority rationale:** This is the foundational feature - without the monorepo structure and platform-ui, nothing else can be built. The dashboard empty state is the first user-facing feature after infrastructure.

**What was done:**
1. Created monorepo infrastructure:
   - root package.json with workspace scripts
   - pnpm-workspace.yaml
   - root tsconfig.json with project references
   - .gitignore

2. Created packages/shared with:
   - Core types: FeatureFlag, TemplateCategory, Theme, RenderConfig
   - API response types
   - Error codes (FEATURE_DISABLED, INVALID_TOKEN)

3. Created apps/platform-ui with:
   - Vite + React setup
   - TanStack Router and Query integration
   - Tailwind CSS with design system tokens (no pure black/white, curated palette)
   - Dashboard component with empty state
   - Layout component with minimal navigation

4. Created services/platform-api with:
   - NestJS scaffold
   - Health endpoint
   - CORS configured for dev

5. Created services/worker and apps/wedding-site stubs

**Design system adherence:**
- Colors use curated warm palette (primary: terracotta, accent: sage)
- No pure #000000 or #FFFFFF
- Typography: serif for headings, sans for body
- Minimal, calm UI with intentional whitespace
- Human language in microcopy ("Welcome to Everbloom", not "No records found")

**Next steps:**
- Run `pnpm install` to install dependencies
- Run `pnpm typecheck` and `pnpm test` to verify
- Implement magic link auth (prerequisite for full dashboard feature)
- Implement Stripe billing flow

**Notes for next person:**
- The dashboard shows an empty state that prompts creation/selection of weddings
- Auth is not yet implemented, so "Log in as admin" step cannot pass yet
- Feature "Admin dashboard loads with no wedding selected" depends on auth feature
- PRD should NOT be marked as passing until auth is in place and verified

---

### 2026-01-06 - Magic Link Authentication

**Feature worked on:** Admin can log in via magic link (PRD: platform category)

**Priority rationale:** This is the highest-priority feature because it unblocks:
1. The dashboard feature (which depends on "Log in as admin" step)
2. All platform features that require authentication
3. Admin-only actions like creating weddings, managing guests, etc.

**What was done:**
1. Fixed NestJS API to use `/api` prefix (was missing, frontend was calling `/api/auth/*` but backend was at `/auth/*`)

2. Added workspace dependency wiring:
   - Added `@wedding-bestie/shared` as dependency to platform-api and platform-ui
   - Built shared package to generate dist/ with types

3. Fixed TypeScript configuration issues:
   - Added `@types/node` and `types: ["node"]` to worker service
   - Excluded astro.config.mjs from wedding-site typecheck

4. Fixed test configuration:
   - Added `--passWithNoTests` to platform-api jest command

**Existing auth implementation (already present, now wired up):**
- Login page (Login.tsx): Email input form, sends POST to `/api/auth/request-link`
- VerifyMagicLink page: Handles `/auth/verify?token=...` callback
- AuthProvider (auth.tsx): Manages session state, stores token in localStorage
- AuthController: `/auth/request-link`, `/auth/verify-link`, `/auth/me`, `/auth/logout`
- AuthService: In-memory token/session storage (dev mode), logs magic link to console
- Routes (__root.tsx): Protected routes redirect to `/login`, login redirects if authenticated

**PRD features now passing:**
- "Admin can log in via magic link" ‚úì
- "Admin dashboard loads with no wedding selected" ‚úì (was blocked by auth, now works)

**Next steps:**
- Implement Stripe billing flow (checkout session creation)
- Implement wedding provisioning on checkout.session.completed webhook
- Generate render_config on wedding creation

**Notes for next person:**
- In dev mode, magic links are logged to console (look for "üîê MAGIC LINK" in platform-api output)
- Sessions are stored in-memory (restart API = logout all users)
- Run `pnpm dev` to start both UI and API together
- To test: enter email on login page, copy magic link from API console, paste in browser

---

### 2026-01-06 - Stripe Checkout Session Creation

**Feature worked on:** Stripe checkout session can be created for a new wedding (PRD: billing category)

**Priority rationale:** This is the next critical feature after auth because:
1. It enables the billing flow - couples can't create weddings without paying
2. It unblocks all downstream features (wedding provisioning, render_config, site rendering)
3. It's the gateway to all wedding-specific functionality

**What was done:**
1. Added Stripe SDK to platform-api:
   - Added `stripe` and `@nestjs/config` dependencies
   - Created BillingModule with controller and service

2. Created billing types in shared package:
   - `PlanTier` (starter | premium)
   - `Plan` interface with id, name, priceId, features
   - `CreateCheckoutSessionRequest` and `CreateCheckoutSessionResponse`
   - `CHECKOUT_SESSION_FAILED` error code

3. Implemented BillingService:
   - `getPlans()` - returns available plans with features
   - `createCheckoutSession()` - creates Stripe checkout session with wedding metadata

4. Implemented BillingController:
   - `GET /api/billing/plans` - public endpoint to get plans
   - `POST /api/billing/checkout-session` - authenticated endpoint to start checkout

5. Created UI flow for wedding creation:
   - CreateWedding component with 2-step form
   - Step 1: Enter wedding name and partner names
   - Step 2: Select plan (Starter or Premium)
   - Redirects to Stripe Checkout on submit

6. Created billing result pages:
   - BillingSuccess: Confirmation page with redirect to dashboard
   - BillingCancel: Friendly cancel page with return option

7. Updated Dashboard to integrate CreateWedding:
   - "Create your wedding site" button now triggers the creation flow
   - Added routes for /billing/success and /billing/cancel

**API Endpoints:**
- `GET /api/billing/plans` - Get available plans (public)
- `POST /api/billing/checkout-session` - Create checkout session (requires auth)
  - Request: `{ planId, weddingName, partnerNames }`
  - Response: `{ checkoutUrl, sessionId }`

**Design system adherence:**
- Step indicator with calm transitions
- Plan cards with clear feature lists
- Human language: "Tell us about your wedding", "Your wedding site is being created"
- No pure black/white colors
- Minimal, focused forms

**PRD features now passing:**
- "Stripe checkout session can be created for a new wedding" ‚úì

**Next steps:**
- Implement Stripe webhook handler for checkout.session.completed
- Provision wedding record on successful payment
- Generate render_config on wedding creation
- Set up Stripe test prices for local development

**Notes for next person:**
- Stripe uses test mode by default (set STRIPE_SECRET_KEY for production)
- Plans use placeholder price IDs (price_starter_test, price_premium_test)
- Set STRIPE_PRICE_STARTER and STRIPE_PRICE_PREMIUM env vars for real prices
- Wedding metadata (name, partners) is stored in checkout session metadata
- The checkout.session.completed webhook will read this metadata to create the wedding

---

### 2026-01-06 - Stripe Webhook and Wedding Provisioning

**Feature worked on:** Successful Stripe checkout provisions a wedding (PRD: billing category)

**Priority rationale:** This is the critical next step after checkout session creation because:
1. Without webhook handling, users can pay but no wedding is created
2. Blocks all downstream features (render_config generation, site rendering, guest management)
3. This is the gateway between payment and actual product delivery

**What was done:**
1. Added Wedding types to shared package:
   - `Wedding` interface with id, userId, slug, name, partnerNames, planId, status, features
   - `CreateWeddingPayload` for provisioning from checkout metadata
   - `WeddingProvisionResponse` for webhook response
   - `WEBHOOK_SIGNATURE_INVALID` error code

2. Created WeddingService (services/platform-api/src/wedding/):
   - In-memory storage for weddings and render_configs (dev mode)
   - `generateSlug()` - creates URL-safe slug from partner names with random suffix
   - `buildFeatureFlags()` - enables features based on plan tier (starter vs premium)
   - `generateRenderConfig()` - creates initial render_config with default template and sections
   - `provisionWedding()` - idempotent wedding creation from checkout completion
   - Session tracking for idempotency (prevents duplicate weddings on webhook replay)

3. Created WeddingModule and wired to BillingModule

4. Added Stripe webhook handler to BillingController:
   - `POST /api/billing/stripe-webhook` endpoint
   - Signature verification using Stripe SDK
   - Handles `checkout.session.completed` event
   - Extracts wedding metadata from session
   - Calls WeddingService.provisionWedding()
   - Returns wedding and render_config on success

5. Updated main.ts to enable raw body parsing for webhook signature verification

**Feature flags by plan:**
- Starter: RSVP, CALENDAR_INVITE
- Premium: All flags (RSVP, CALENDAR_INVITE, PHOTO_UPLOAD, ANNOUNCEMENT_BANNER, FAQ_SECTION, PASSCODE_SITE)

**Default theme:**
- Primary: #c9826b (terracotta)
- Accent: #8fac8b (sage)
- Neutral Light: #faf8f5 (warm off-white)
- Neutral Dark: #2d2d2d (soft black)

**API Endpoints:**
- `POST /api/billing/stripe-webhook` - Stripe webhook handler
  - Requires `stripe-signature` header
  - Requires raw body for signature verification
  - Handles `checkout.session.completed` to provision weddings
  - Idempotent - same session ID will not create duplicate weddings

**PRD features now passing:**
- "Successful Stripe checkout provisions a wedding" ‚úì

**Next steps:**
- Note: "Wedding site render_config is generated on provisioning" is already implemented as part of this feature
- Next feature should be wedding site rendering from render_config
- Or implement feature toggle UI in admin dashboard

**Notes for next person:**
- In dev mode, weddings and render_configs are stored in-memory (restart API = lose data)
- Webhook requires `STRIPE_WEBHOOK_SECRET` env var for production
- For local testing, use Stripe CLI: `stripe listen --forward-to localhost:3001/api/billing/stripe-webhook`
- Slugs are generated as `partner1-and-partner2-{random}` (URL-safe, lowercase)
- The render_config generation is already in place - provisioning feature passes

---

### 2026-01-06 - Wedding render_config API Endpoint

**Feature worked on:** Wedding site render_config is generated on provisioning (PRD: provisioning category)

**Priority rationale:** This was the highest-priority incomplete feature because:
1. The render_config generation logic was already implemented in WeddingService
2. However, there was no API endpoint to fetch the render_config
3. This blocks the wedding site rendering feature (which needs to consume render_config)
4. Without an endpoint, the PRD step "Fetch wedding_sites.render_config" could not pass

**What was done:**
1. Created WeddingController (services/platform-api/src/wedding/wedding.controller.ts):
   - `GET /api/weddings` - List all weddings for authenticated user
   - `GET /api/weddings/:id` - Get a specific wedding by ID
   - `GET /api/weddings/:id/render-config` - Fetch render_config for a wedding
   - All endpoints require authentication and verify ownership

2. Updated WeddingModule to:
   - Import AuthModule (using forwardRef to avoid circular dependency)
   - Register WeddingController

3. Updated AppModule to:
   - Import WeddingModule directly (previously only imported via BillingModule)

**API Endpoints added:**
- `GET /api/weddings` - Returns user's weddings array
- `GET /api/weddings/:id` - Returns wedding details
- `GET /api/weddings/:id/render-config` - Returns the render_config object containing:
  - `templateId` (e.g., "minimal-001")
  - `theme` (primary, accent, neutralLight, neutralDark)
  - `features` (feature flags record based on plan)
  - `sections` (array of section definitions)
  - `wedding` (slug, partnerNames)

**PRD features now passing:**
- "Wedding site render_config is generated on provisioning" ‚úì

**Next steps:**
- Implement wedding site rendering from render_config (site category)
- This will require updating the Astro wedding site to fetch and render from the config

**Notes for next person:**
- The render_config is stored in-memory alongside weddings (dev mode)
- Endpoint requires Bearer token authentication
- Only the wedding owner can fetch their render_config
- The config contains all data needed for the wedding site to render without additional DB queries

---

### 2026-01-06 - Wedding Site Renders from render_config

**Feature worked on:** Wedding site renders exclusively from render_config (PRD: site category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. It completes the provisioning‚Üírendering pipeline
2. It unblocks all guest-facing features (RSVP, photos, announcements)
3. Without a rendered wedding site, none of the other guest-facing features can be tested
4. It demonstrates the core architecture: platform provisions, site renders

**What was done:**
1. Added public endpoint for wedding site config:
   - `GET /api/site-config/:slug` - No auth required, wedding slug is the identifier
   - Created SiteConfigController (services/platform-api/src/wedding/site-config.controller.ts)
   - Returns render_config for active weddings only

2. Added shared package dependency to wedding-site:
   - Added `@wedding-bestie/shared` workspace dependency for types

3. Created API client for fetching site config:
   - `apps/wedding-site/src/lib/api.ts`
   - `fetchSiteConfig(slug)` - single fetch for all rendering data

4. Created Astro components for wedding site rendering:
   - `WeddingLayout.astro` - Base layout with theme CSS variables and fonts
   - `SectionRenderer.astro` - Maps section types to components, respects feature flags
   - `HeroSection.astro` - Hero section with partner names headline
   - `EventDetailsSection.astro` - Event details with date, venue, city
   - `RsvpSection.astro` - RSVP CTA section (only renders if RSVP feature enabled)

5. Created dynamic route `/w/[slug]`:
   - `apps/wedding-site/src/pages/w/[slug].astro`
   - Fetches render_config via single API call (no database joins)
   - Returns 404 if wedding not found or inactive

**Architecture adherence:**
- Wedding site renders EXCLUSIVELY from render_config (no direct DB queries)
- Single data fetch per page load
- Feature flags respected (RSVP section only shows if feature enabled)
- Theme CSS variables set from render_config theme
- No joins, no multi-table queries

**Design system adherence:**
- Typography: Cormorant Garamond (serif) for headings, Inter (sans) for body
- Colors: Theme-driven via CSS variables (no hardcoded colors)
- No pure black (#000000) or pure white (#FFFFFF)
- Generous whitespace, calm visual style
- Mobile-first responsive design

**API Endpoints added:**
- `GET /api/site-config/:slug` - Public endpoint for wedding site rendering
  - Returns render_config with template, theme, features, sections, wedding info
  - No authentication required
  - Returns 404 for non-existent or inactive weddings

**PRD features now passing:**
- "Wedding site renders exclusively from render_config" ‚úì

**Next steps:**
- Implement template switching feature in admin dashboard
- Or implement guest-facing RSVP flow
- Consider adding announcement banner rendering

**Notes for next person:**
- Wedding sites are at `/w/{slug}` (e.g., `/w/john-and-jane-abc123`)
- The site fetches config from platform-api at startup
- Set `PUBLIC_PLATFORM_API_URL` env var for production deployment
- In dev, defaults to `http://localhost:3001/api`
- To test: create a wedding via Stripe checkout, then visit `/w/{slug}`

---

### 2026-01-06 - Admin Can Add Invitees Manually

**Feature worked on:** Admin can add invitees manually (PRD: guests category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. It's the foundation for all guest management features
2. Without guests, RSVP and invitation features cannot function
3. It completes the core admin workflow: login ‚Üí create wedding ‚Üí add guests
4. It unblocks downstream features: CSV import, sending invites, RSVP tracking

**What was done:**
1. Added Guest types to shared package:
   - `RsvpStatus` type ('pending' | 'attending' | 'not_attending')
   - `Guest` interface with all guest fields (id, weddingId, name, email, partySize, rsvpStatus, etc.)
   - `CreateGuestRequest` and `UpdateGuestRequest` for API calls
   - `GuestListResponse` for list endpoint
   - Error codes: `GUEST_NOT_FOUND`, `GUEST_ALREADY_EXISTS`, `WEDDING_NOT_FOUND`

2. Created GuestService (services/platform-api/src/guest/guest.service.ts):
   - In-memory storage for development
   - `createGuest()` - creates new guest with RSVP token, checks for duplicate emails
   - `updateGuest()` - updates guest details
   - `deleteGuest()` - removes guest
   - `getGuest()` / `getGuestsForWedding()` - retrieval methods
   - `getGuestSummary()` - aggregates RSVP counts

3. Created GuestController (services/platform-api/src/guest/guest.controller.ts):
   - `GET /api/weddings/:weddingId/guests` - list all guests
   - `POST /api/weddings/:weddingId/guests` - create guest
   - `GET /api/weddings/:weddingId/guests/:guestId` - get single guest
   - `PUT /api/weddings/:weddingId/guests/:guestId` - update guest
   - `DELETE /api/weddings/:weddingId/guests/:guestId` - delete guest
   - All endpoints require authentication and verify wedding ownership

4. Created GuestModule and registered in AppModule

5. Created Guests page component (apps/platform-ui/src/components/Guests.tsx):
   - List view with guest cards showing name, email, RSVP status
   - Add guest form with name and email inputs
   - Delete functionality with confirmation
   - Empty state with friendly messaging
   - Loading states

6. Updated Dashboard component:
   - Now fetches weddings from API on mount
   - Auto-selects first wedding if only one exists
   - Shows wedding selection when multiple weddings
   - WeddingDashboard view with navigation cards
   - "Your guests" card navigates to Guests page
   - "Your site" card links to wedding site

**API Endpoints:**
- `GET /api/weddings/:weddingId/guests` - List guests (requires auth)
- `POST /api/weddings/:weddingId/guests` - Create guest (requires auth)
- `GET /api/weddings/:weddingId/guests/:guestId` - Get guest (requires auth)
- `PUT /api/weddings/:weddingId/guests/:guestId` - Update guest (requires auth)
- `DELETE /api/weddings/:weddingId/guests/:guestId` - Delete guest (requires auth)

**Design system adherence:**
- Calm, minimal UI with intentional whitespace
- Human language: "Your guests", "Add your first guest", "No guests yet"
- RSVP status badges with muted colors
- No pure black/white colors
- Large, clear form inputs

**PRD features now passing:**
- "Admin can add invitees manually" ‚úì

**Next steps:**
- Implement CSV import for bulk guest adding
- Implement invitation sending
- Implement guest-facing RSVP flow

**Notes for next person:**
- Guests are stored in-memory (restart API = lose data)
- Each guest gets a unique RSVP token on creation (32 bytes, hex encoded)
- Duplicate email check is per-wedding (same email can be in different weddings)
- Dashboard auto-selects first wedding if user has only one
- Guest list is sorted alphabetically by name

---

### 2026-01-06 - Guest RSVP Flow (View, Submit, Edit)

**Feature worked on:** Guest can view RSVP form via tokenized link (PRD: rsvp category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. Guests are the core users of the wedding site
2. RSVP is the primary guest interaction for most weddings
3. We already have guests with tokens from the admin add feature
4. It unlocks the guest-facing value of the platform
5. It's foundational for invitation sending (next feature)

**What was done:**
1. Added RSVP types to shared package:
   - `RsvpGuestView` - guest data subset for RSVP (excludes sensitive fields like token)
   - `RsvpWeddingView` - minimal wedding info for RSVP display
   - `RsvpViewData` - combined response with guest, wedding, and theme
   - `RsvpSubmitRequest` - submission payload with token, status, partySize, dietaryNotes
   - `RsvpSubmitResponse` - confirmation message and updated guest data

2. Added guest token lookup to GuestService:
   - `getGuestByRsvpToken(token)` - finds guest by RSVP token
   - `updateRsvpStatus(guestId, status, partySize, dietaryNotes)` - updates RSVP response

3. Created RsvpController (services/platform-api/src/rsvp/):
   - `GET /api/rsvp/view?token=...` - Fetches guest data for RSVP form
     - Validates token exists and is valid
     - Checks wedding is active
     - Checks RSVP feature is enabled
     - Returns deterministic errors: INVALID_TOKEN, FEATURE_DISABLED, WEDDING_NOT_FOUND
   - `POST /api/rsvp/submit` - Submits/updates RSVP response
     - Same validation as view endpoint
     - Updates guest's RSVP status, party size, dietary notes
     - Sets rsvpSubmittedAt timestamp
     - Returns confirmation message

4. Created RsvpModule and registered in AppModule

5. Updated wedding-site API client:
   - Added `fetchRsvpView(token)` function
   - Added `submitRsvp(request)` function

6. Created RSVP page (apps/wedding-site/src/pages/rsvp/index.astro):
   - Route: `/rsvp?token=...`
   - Mobile-first responsive design
   - Large tap targets for RSVP options
   - Stepper control for party size (not tiny input)
   - Optional dietary notes (below the fold)
   - Shows previous response if guest already RSVP'd
   - Success confirmation with celebratory message
   - Error handling with friendly messages

**API Endpoints:**
- `GET /api/rsvp/view?token=...` - Public endpoint for RSVP form data
  - Returns: guest info, wedding details, theme
  - Errors: INVALID_TOKEN, FEATURE_DISABLED, WEDDING_NOT_FOUND
- `POST /api/rsvp/submit` - Public endpoint for RSVP submission
  - Request: { token, rsvpStatus, partySize, dietaryNotes? }
  - Returns: confirmation message, updated guest data

**Design system adherence:**
- Mobile-first with large 48px tap targets
- One-question-per-block layout (status ‚Üí party size ‚Üí dietary)
- Calm, celebratory language ("Joyfully accept", "We can't wait to celebrate with you")
- Stepper control for party size (not tiny input)
- Theme colors from wedding's render_config
- No pure black/white colors
- Serif headings (Cormorant Garamond), sans body (Inter)

**PRD features now passing:**
- "Guest can view RSVP form via tokenized link" ‚úì
- "Guest can submit RSVP" ‚úì
- "Guest can edit RSVP using same link" ‚úì

**Next steps:**
- Implement admin RSVP summary dashboard
- Implement invitation email sending
- Implement CSV import for bulk guest adding

**Notes for next person:**
- RSVP link format: `/rsvp?token={64-char-hex-token}`
- Tokens are stored as plain text in dev mode (production should hash)
- Re-visiting RSVP link shows previous response and allows changes
- Dietary notes are optional and hidden until "Attending" is selected
- Party size stepper has min=1, max=20
- Error messages use human language (not technical codes)
- The RsvpSection on wedding site links to /w/{slug}/rsvp which doesn't exist yet (future: request RSVP link page)

---

### 2026-01-06 - Admin RSVP Summary Dashboard

**Feature worked on:** Admin can view RSVP summary (PRD: dashboard category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. RSVP features for guests are complete (view, submit, edit)
2. Admin needs visibility into RSVP status to manage their wedding
3. It's core dashboard functionality - admin must know who's coming
4. Simple to implement since GuestService already has getGuestSummary()
5. Completes the admin's wedding management workflow

**What was done:**
1. Added RSVP summary types to shared package:
   - `RsvpSummary` interface with total, attending, notAttending, pending, totalPartySize
   - `RsvpSummaryResponse` combining summary with guest list

2. Added summary API endpoint to GuestController:
   - `GET /api/weddings/:weddingId/guests/summary` - authenticated endpoint
   - Returns RSVP counts and full guest list for the wedding
   - Reuses existing GuestService.getGuestSummary() method

3. Created RsvpDashboard component (apps/platform-ui/src/components/RsvpDashboard.tsx):
   - Summary cards showing: Attending (with total party size), Not attending, Awaiting response, Total invited
   - Guest list grouped by RSVP status (attending, not attending, pending)
   - Shows party size and dietary notes for attending guests
   - Shows RSVP submission date when available
   - Empty state with friendly messaging
   - Loading state with spinner

4. Updated Dashboard component:
   - Added "RSVP responses" card in WeddingDashboard
   - Added navigation to RsvpDashboard view
   - Added ClipboardIcon for the new card

**API Endpoints:**
- `GET /api/weddings/:weddingId/guests/summary` - Get RSVP summary (requires auth)
  - Returns: { summary: RsvpSummary, guests: Guest[] }
  - Summary includes: total, attending, notAttending, pending, totalPartySize

**Design system adherence:**
- Summary cards with calm colors (accent for attending, neutral for others)
- Guest lists grouped by status with clear section headers
- Human language: "Awaiting response" not "Pending", "Track who's coming" not "View RSVPs"
- No pure black/white colors
- Minimal, scannable layout

**PRD features now passing:**
- "Admin can view RSVP summary" ‚úì

**Next steps:**
- Implement CSV import for bulk guest adding
- Implement invitation email sending
- Implement photo upload feature

**Notes for next person:**
- RSVP summary is available at /api/weddings/:weddingId/guests/summary
- Dashboard now has 3 cards: Your guests, RSVP responses, Your site
- Guests are grouped by RSVP status in the dashboard for easy scanning
- totalPartySize counts only attending guests' party sizes

---

### 2026-01-06 - CSV Import for Guests

**Feature worked on:** Admin can import invitees via CSV (PRD: guests category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. Most weddings have 50-200+ guests - manual entry is impractical
2. It's a natural extension of the existing guest management infrastructure
3. It doesn't require new infrastructure (unlike photos which needs storage, or emails which needs SendGrid)
4. It unblocks bulk guest workflows and makes the platform production-ready for real weddings

**What was done:**
1. Added CSV import types to shared package:
   - `CsvGuestRow` - a single row from CSV (name, email, partySize)
   - `CsvImportRowResult` - result per row with success/error status
   - `CsvImportRequest` - request body containing guest rows
   - `CsvImportResponse` - response with imported/skipped counts and results
   - `CSV_IMPORT_VALIDATION_ERROR` error code

2. Added bulk import method to GuestService:
   - `importGuestsFromCsv(weddingId, rows)` - processes CSV rows
   - Validates each row (name required, email required, email format)
   - Checks for duplicate emails within the wedding
   - Returns detailed results per row
   - Made `findByEmail` method public for duplicate checking

3. Added CSV import endpoint to GuestController:
   - `POST /api/weddings/:weddingId/guests/import` - authenticated endpoint
   - Validates request has guests array
   - Limits import size to 500 guests per request
   - Returns detailed results with imported/skipped counts

4. Added CSV import UI to Guests page:
   - Multi-step import flow: Upload ‚Üí Map columns ‚Üí Confirm ‚Üí Results
   - CSV file parsing with quote handling
   - Auto-detection of name/email/partySize columns from headers
   - Column mapping UI with dropdowns
   - Preview of first 5 rows with mapped data
   - Import confirmation step
   - Results summary showing imported/skipped counts
   - Detailed skipped rows table with error reasons

**API Endpoints:**
- `POST /api/weddings/:weddingId/guests/import` - Bulk import guests (requires auth)
  - Request: `{ guests: CsvGuestRow[] }`
  - Response: `{ imported, skipped, total, results: CsvImportRowResult[] }`
  - Max 500 guests per request

**Design system adherence:**
- Multi-step wizard with clear progress indicator
- Drag-and-drop upload zone with file picker fallback
- Clean preview table for column mapping verification
- Summary cards for import results (imported/skipped)
- Human language: "Import guests from CSV", "Map columns", "Guests with invalid data..."
- No pure black/white colors
- Calm, minimal UI

**PRD features now passing:**
- "Admin can import invitees via CSV" ‚úì

**Next steps:**
- Implement invitation email sending
- Implement photo upload feature
- Implement announcement banner feature

**Notes for next person:**
- CSV import endpoint is at POST /api/weddings/:weddingId/guests/import
- Maximum 500 guests per import to prevent timeout
- CSV parser handles quoted fields (e.g., "Smith, John")
- Column auto-detection looks for "name", "email", "party"/"size"/"guests" in headers
- Duplicate emails within the same wedding are skipped
- Import results include per-row error details for debugging
- The import form maintains step state and shows results before closing

---

### 2026-01-06 - Admin Can Send Invitation Emails

**Feature worked on:** Admin can send invitation emails (PRD: invites category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. The entire RSVP flow is complete (guests can view/submit/edit RSVP)
2. But there's no way to actually SEND the RSVP links to guests
3. Without invitation sending, the guest management features are incomplete
4. It completes the core guest workflow: add guests ‚Üí send invites ‚Üí guests RSVP

**What was done:**
1. Added invitation/email types to shared package:
   - `EmailStatus` type ('pending' | 'sent' | 'failed')
   - `EmailType` type ('invitation' | 'reminder' | 'update')
   - `EmailOutbox` interface for tracking sent emails
   - `SendInvitationsRequest`, `SendInvitationResult`, `SendInvitationsResponse`
   - `EMAIL_SEND_FAILED`, `NO_GUESTS_SELECTED` error codes

2. Created EmailService (services/platform-api/src/invitation/email.service.ts):
   - `buildInvitationEmail(guest, wedding)` - generates personalized HTML/text email content
   - `sendEmail(content)` - sends via SendGrid API in production, logs in development
   - Beautiful, branded email template with RSVP link
   - Development mode: logs email to console instead of actually sending

3. Created InvitationService (services/platform-api/src/invitation/invitation.service.ts):
   - In-memory email_outbox storage for development
   - `createOutboxRecord()` - tracks email attempts
   - `updateOutboxStatus()` - updates status on send success/failure
   - `sendInvitations(weddingId, guestIds)` - batch sends invitations
   - `getOutboxForWedding()` / `getOutboxForGuest()` - retrieval methods

4. Created InvitationController (services/platform-api/src/invitation/invitation.controller.ts):
   - `POST /api/weddings/:weddingId/invitations/send` - send invitations to selected guests
   - `GET /api/weddings/:weddingId/invitations/outbox` - get email history
   - All endpoints require authentication and verify wedding ownership

5. Created InvitationModule and registered in AppModule

6. Updated Guests page component (apps/platform-ui/src/components/Guests.tsx):
   - Added guest selection with checkboxes
   - Added "Select all" / "Deselect all" functionality
   - Added "Send invites" button that appears when guests are selected
   - Created SendInvitesDialog component:
     - Confirmation view showing selected guests
     - Sends invitation via API
     - Results view showing sent/failed counts
     - Error handling with friendly messages

**API Endpoints:**
- `POST /api/weddings/:weddingId/invitations/send` - Send invitations (requires auth)
  - Request: `{ guestIds: string[] }`
  - Response: `{ sent, failed, total, results: SendInvitationResult[] }`
- `GET /api/weddings/:weddingId/invitations/outbox` - Get email outbox (requires auth)
  - Response: `{ emails: EmailOutbox[] }`

**Design system adherence:**
- Checkbox selection with primary color fill
- Modal dialog for send confirmation
- Clear summary cards for sent/failed counts
- Human language: "Send invitations", "Invitations sent", "Sent successfully"
- No pure black/white colors
- Calm, minimal UI with branded email template

**PRD features now passing:**
- "Admin can send invitation emails" ‚úì

**Next steps:**
- Implement photo upload feature
- Implement announcement banner feature
- Implement reminder emails via worker queue

**Notes for next person:**
- In dev mode, emails are logged to console (look for "üìß DEVELOPMENT MODE" in platform-api output)
- In production, set SENDGRID_API_KEY, SENDGRID_FROM_EMAIL, SENDGRID_FROM_NAME env vars
- Set WEDDING_SITE_URL env var for RSVP links in emails (defaults to http://localhost:4321)
- Email outbox tracks all sends with status (pending/sent/failed)
- The invitation email includes a personalized RSVP link with the guest's token
- To test: add guests ‚Üí select them ‚Üí click "Send invites" ‚Üí check API console for logged emails

---

### 2026-01-06 - Template Switching Without Content Loss

**Feature worked on:** Template can be switched without losing content (PRD: site category)

**Priority rationale:** This is a high-priority feature because:
1. Template switching is core to the product value proposition
2. The render_config architecture already supports it conceptually
3. It completes the wedding site customization workflow
4. It allows couples to explore different visual styles before their wedding

**What was done:**
1. Added template types to shared package:
   - `Template` interface with id, name, category, description, defaultTheme
   - `ChangeTemplateRequest` and `ChangeTemplateResponse` types
   - `TemplatesListResponse` for listing available templates
   - `TEMPLATE_NOT_FOUND` error code

2. Added template definitions in WeddingService:
   - 5 curated templates across categories (Minimal, Classic, Modern, Destination)
   - Serene (minimal-001): Clean lines and generous whitespace
   - Whisper (minimal-002): Soft tones and delicate typography
   - Heritage (classic-001): Timeless design with traditional flourishes
   - Edge (modern-001): Bold typography and contemporary layouts
   - Wanderlust (destination-001): Travel-inspired design

3. Added template methods to WeddingService:
   - `getTemplates()` - returns all available templates
   - `getTemplate(id)` - returns a single template by ID
   - `changeTemplate(weddingId, templateId)` - changes template while preserving content
   - Content preservation: sections data remains intact, only templateId and theme change

4. Added API endpoints to WeddingController:
   - `GET /api/weddings/templates/list` - List all available templates (public)
   - `PUT /api/weddings/:id/template` - Change wedding template (requires auth)

5. Created TemplateSelector component (apps/platform-ui/src/components/TemplateSelector.tsx):
   - Template grid with visual previews using theme colors
   - Shows current template with "Current" badge
   - Color swatch preview for selected template
   - Save/Cancel buttons with loading states
   - Success message on template change

6. Updated Dashboard component:
   - Added "Site template" card with palette icon
   - Added template view navigation
   - Created TemplateSelectorWrapper to fetch current template
   - PaletteIcon component for the dashboard card

**API Endpoints:**
- `GET /api/weddings/templates/list` - Get all available templates (public)
  - Returns: `{ templates: Template[] }`
- `PUT /api/weddings/:id/template` - Change wedding template (requires auth)
  - Request: `{ templateId: string }`
  - Response: `{ renderConfig: RenderConfig }`
  - Content (sections) is preserved, only visual style changes

**Design system adherence:**
- Curated palette of 5 templates across categories (not arbitrary selection)
- Template previews show actual theme colors
- No pure black/white in any template theme
- Human language: "Choose your visual style", "Your content will be preserved"
- Calm, minimal UI with clear selection states

**PRD features now passing:**
- "Template can be switched without losing content" ‚úì

**Next steps:**
- Implement feature selection step during wedding setup
- Implement feature toggle UI in admin dashboard
- Implement photo upload feature
- Implement announcement banner feature

**Notes for next person:**
- Templates are defined in WeddingService as TEMPLATES constant
- Each template has a defaultTheme that is applied when switching
- Content (sections array) is preserved during template switch
- Template list endpoint is public, change endpoint requires auth
- The wedding site renders from render_config which includes templateId
- To test: create wedding ‚Üí go to dashboard ‚Üí click "Site template" ‚Üí select new template ‚Üí save ‚Üí view site

---

### 2026-01-06 - Admin Can Disable RSVP Feature

**Feature worked on:** Disabling RSVP hides RSVP on public site + Disabling RSVP blocks RSVP API endpoints (PRD: features category)

**Priority rationale:** This is a high-priority feature because:
1. Feature flags are foundational to the product architecture
2. The feature flag infrastructure already existed but admins couldn't toggle them
3. Without this, users can't customize which features are active on their site
4. It validates the end-to-end feature flag flow: admin toggles ‚Üí site renders ‚Üí API blocks

**What was done:**
1. Added feature toggle types to shared package:
   - `UpdateFeaturesRequest` - partial feature flag updates
   - `UpdateFeaturesResponse` - returns updated wedding and render_config

2. Added `updateFeatures` method to WeddingService:
   - Updates wedding.features record
   - Regenerates render_config with updated features
   - Updates section enabled states based on feature flags (e.g., RSVP section disabled when RSVP flag is false)

3. Added API endpoint to WeddingController:
   - `PUT /api/weddings/:id/features` - authenticated endpoint to toggle features
   - Validates ownership and updates feature flags
   - Returns updated wedding and render_config

4. Created FeatureSettings component (apps/platform-ui/src/components/FeatureSettings.tsx):
   - Feature toggle UI with on/off switches for each flag
   - Shows feature descriptions in human language
   - Indicates which features require Premium plan
   - Disables unavailable features based on plan tier
   - Save/Cancel buttons with loading states

5. Updated Dashboard component:
   - Added "Site features" card to WeddingDashboard
   - Added features view navigation
   - Added ToggleIcon for the dashboard card

**How feature disabling works (already implemented, now toggleable):**
- Wedding site: `SectionRenderer.astro` checks `features.RSVP` before rendering RSVP section
- RSVP page: Shows "RSVPs are currently closed for this event." when feature disabled
- RSVP API: Both `/api/rsvp/view` and `/api/rsvp/submit` return `FEATURE_DISABLED` error

**API Endpoints:**
- `PUT /api/weddings/:id/features` - Update feature flags (requires auth)
  - Request: `{ features: { RSVP: boolean, PHOTO_UPLOAD: boolean, ... } }`
  - Response: `{ wedding: Wedding, renderConfig: RenderConfig }`

**Design system adherence:**
- Toggle switches with primary color when enabled
- Feature descriptions in human language
- Premium features shown but disabled with plan indicator
- Calm, minimal UI with clear save/cancel actions
- No pure black/white colors

**PRD features now passing:**
- "Disabling RSVP hides RSVP on public site" ‚úì
- "Disabling RSVP blocks RSVP API endpoints" ‚úì

**Next steps:**
- Implement feature selection step during wedding setup
- Implement photo upload feature
- Implement announcement banner feature

**Notes for next person:**
- Feature toggles are at PUT /api/weddings/:id/features
- Dashboard has a new "Site features" card to access settings
- Starter plan only allows RSVP and CALENDAR_INVITE toggles
- Premium plan allows all 6 feature toggles
- When RSVP is disabled, the render_config is updated with features.RSVP=false AND sections[rsvp].enabled=false
- The wedding site reads features from render_config, so changes are immediate
- To test: create wedding ‚Üí dashboard ‚Üí "Site features" ‚Üí toggle RSVP off ‚Üí save ‚Üí visit wedding site ‚Üí RSVP section should be gone

### 2026-01-07 - Feature Selection Applied During Wedding Setup

**Feature worked on:** Feature selection step available during wedding setup (PRD: features category)

**Priority rationale:** This ensures the feature selection step during wedding creation is not just cosmetic by persisting the chosen toggles into provisioning. It aligns the setup flow with the per-wedding feature flag architecture and keeps the initial render_config accurate.

**What was done:**
1. Applied feature selections during provisioning:
   - WeddingService now accepts an optional feature selection payload
   - Features are filtered by plan tier and default to enabled when not explicitly set

2. Wired Stripe webhook metadata into provisioning:
   - Parsed feature selections from checkout session metadata
   - Passed normalized flags into wedding provisioning

**PRD features now passing:**
- "Feature selection step available during wedding setup" ‚úì

**Notes for next person:**
- Feature selection is stored in Stripe checkout metadata as JSON
- Provisioning now respects selected toggles while still enforcing plan eligibility
- If no feature selection is provided, plan defaults still enable all allowed features
