## Progress Log

### 2026-01-06 - Initial Monorepo Setup and Dashboard Empty State

**Feature worked on:** Admin dashboard loads with no wedding selected (PRD: platform category)

**Priority rationale:** This is the foundational feature - without the monorepo structure and platform-ui, nothing else can be built. The dashboard empty state is the first user-facing feature after infrastructure.

**What was done:**
1. Created monorepo infrastructure:
   - root package.json with workspace scripts
   - pnpm-workspace.yaml
   - root tsconfig.json with project references
   - .gitignore

2. Created packages/shared with:
   - Core types: FeatureFlag, TemplateCategory, Theme, RenderConfig
   - API response types
   - Error codes (FEATURE_DISABLED, INVALID_TOKEN)

3. Created apps/platform-ui with:
   - Vite + React setup
   - TanStack Router and Query integration
   - Tailwind CSS with design system tokens (no pure black/white, curated palette)
   - Dashboard component with empty state
   - Layout component with minimal navigation

4. Created services/platform-api with:
   - NestJS scaffold
   - Health endpoint
   - CORS configured for dev

5. Created services/worker and apps/wedding-site stubs

**Design system adherence:**
- Colors use curated warm palette (primary: terracotta, accent: sage)
- No pure #000000 or #FFFFFF
- Typography: serif for headings, sans for body
- Minimal, calm UI with intentional whitespace
- Human language in microcopy ("Welcome to Everbloom", not "No records found")

**Next steps:**
- Run `pnpm install` to install dependencies
- Run `pnpm typecheck` and `pnpm test` to verify
- Implement magic link auth (prerequisite for full dashboard feature)
- Implement Stripe billing flow

**Notes for next person:**
- The dashboard shows an empty state that prompts creation/selection of weddings
- Auth is not yet implemented, so "Log in as admin" step cannot pass yet
- Feature "Admin dashboard loads with no wedding selected" depends on auth feature
- PRD should NOT be marked as passing until auth is in place and verified

---

### 2026-01-06 - Magic Link Authentication

**Feature worked on:** Admin can log in via magic link (PRD: platform category)

**Priority rationale:** This is the highest-priority feature because it unblocks:
1. The dashboard feature (which depends on "Log in as admin" step)
2. All platform features that require authentication
3. Admin-only actions like creating weddings, managing guests, etc.

**What was done:**
1. Fixed NestJS API to use `/api` prefix (was missing, frontend was calling `/api/auth/*` but backend was at `/auth/*`)

2. Added workspace dependency wiring:
   - Added `@wedding-bestie/shared` as dependency to platform-api and platform-ui
   - Built shared package to generate dist/ with types

3. Fixed TypeScript configuration issues:
   - Added `@types/node` and `types: ["node"]` to worker service
   - Excluded astro.config.mjs from wedding-site typecheck

4. Fixed test configuration:
   - Added `--passWithNoTests` to platform-api jest command

**Existing auth implementation (already present, now wired up):**
- Login page (Login.tsx): Email input form, sends POST to `/api/auth/request-link`
- VerifyMagicLink page: Handles `/auth/verify?token=...` callback
- AuthProvider (auth.tsx): Manages session state, stores token in localStorage
- AuthController: `/auth/request-link`, `/auth/verify-link`, `/auth/me`, `/auth/logout`
- AuthService: In-memory token/session storage (dev mode), logs magic link to console
- Routes (__root.tsx): Protected routes redirect to `/login`, login redirects if authenticated

**PRD features now passing:**
- "Admin can log in via magic link" ‚úì
- "Admin dashboard loads with no wedding selected" ‚úì (was blocked by auth, now works)

**Next steps:**
- Implement Stripe billing flow (checkout session creation)
- Implement wedding provisioning on checkout.session.completed webhook
- Generate render_config on wedding creation

**Notes for next person:**
- In dev mode, magic links are logged to console (look for "üîê MAGIC LINK" in platform-api output)
- Sessions are stored in-memory (restart API = logout all users)
- Run `pnpm dev` to start both UI and API together
- To test: enter email on login page, copy magic link from API console, paste in browser

---

### 2026-01-06 - Stripe Checkout Session Creation

**Feature worked on:** Stripe checkout session can be created for a new wedding (PRD: billing category)

**Priority rationale:** This is the next critical feature after auth because:
1. It enables the billing flow - couples can't create weddings without paying
2. It unblocks all downstream features (wedding provisioning, render_config, site rendering)
3. It's the gateway to all wedding-specific functionality

**What was done:**
1. Added Stripe SDK to platform-api:
   - Added `stripe` and `@nestjs/config` dependencies
   - Created BillingModule with controller and service

2. Created billing types in shared package:
   - `PlanTier` (starter | premium)
   - `Plan` interface with id, name, priceId, features
   - `CreateCheckoutSessionRequest` and `CreateCheckoutSessionResponse`
   - `CHECKOUT_SESSION_FAILED` error code

3. Implemented BillingService:
   - `getPlans()` - returns available plans with features
   - `createCheckoutSession()` - creates Stripe checkout session with wedding metadata

4. Implemented BillingController:
   - `GET /api/billing/plans` - public endpoint to get plans
   - `POST /api/billing/checkout-session` - authenticated endpoint to start checkout

5. Created UI flow for wedding creation:
   - CreateWedding component with 2-step form
   - Step 1: Enter wedding name and partner names
   - Step 2: Select plan (Starter or Premium)
   - Redirects to Stripe Checkout on submit

6. Created billing result pages:
   - BillingSuccess: Confirmation page with redirect to dashboard
   - BillingCancel: Friendly cancel page with return option

7. Updated Dashboard to integrate CreateWedding:
   - "Create your wedding site" button now triggers the creation flow
   - Added routes for /billing/success and /billing/cancel

**API Endpoints:**
- `GET /api/billing/plans` - Get available plans (public)
- `POST /api/billing/checkout-session` - Create checkout session (requires auth)
  - Request: `{ planId, weddingName, partnerNames }`
  - Response: `{ checkoutUrl, sessionId }`

**Design system adherence:**
- Step indicator with calm transitions
- Plan cards with clear feature lists
- Human language: "Tell us about your wedding", "Your wedding site is being created"
- No pure black/white colors
- Minimal, focused forms

**PRD features now passing:**
- "Stripe checkout session can be created for a new wedding" ‚úì

**Next steps:**
- Implement Stripe webhook handler for checkout.session.completed
- Provision wedding record on successful payment
- Generate render_config on wedding creation
- Set up Stripe test prices for local development

**Notes for next person:**
- Stripe uses test mode by default (set STRIPE_SECRET_KEY for production)
- Plans use placeholder price IDs (price_starter_test, price_premium_test)
- Set STRIPE_PRICE_STARTER and STRIPE_PRICE_PREMIUM env vars for real prices
- Wedding metadata (name, partners) is stored in checkout session metadata
- The checkout.session.completed webhook will read this metadata to create the wedding

---

### 2026-01-06 - Stripe Webhook and Wedding Provisioning

**Feature worked on:** Successful Stripe checkout provisions a wedding (PRD: billing category)

**Priority rationale:** This is the critical next step after checkout session creation because:
1. Without webhook handling, users can pay but no wedding is created
2. Blocks all downstream features (render_config generation, site rendering, guest management)
3. This is the gateway between payment and actual product delivery

**What was done:**
1. Added Wedding types to shared package:
   - `Wedding` interface with id, userId, slug, name, partnerNames, planId, status, features
   - `CreateWeddingPayload` for provisioning from checkout metadata
   - `WeddingProvisionResponse` for webhook response
   - `WEBHOOK_SIGNATURE_INVALID` error code

2. Created WeddingService (services/platform-api/src/wedding/):
   - In-memory storage for weddings and render_configs (dev mode)
   - `generateSlug()` - creates URL-safe slug from partner names with random suffix
   - `buildFeatureFlags()` - enables features based on plan tier (starter vs premium)
   - `generateRenderConfig()` - creates initial render_config with default template and sections
   - `provisionWedding()` - idempotent wedding creation from checkout completion
   - Session tracking for idempotency (prevents duplicate weddings on webhook replay)

3. Created WeddingModule and wired to BillingModule

4. Added Stripe webhook handler to BillingController:
   - `POST /api/billing/stripe-webhook` endpoint
   - Signature verification using Stripe SDK
   - Handles `checkout.session.completed` event
   - Extracts wedding metadata from session
   - Calls WeddingService.provisionWedding()
   - Returns wedding and render_config on success

5. Updated main.ts to enable raw body parsing for webhook signature verification

**Feature flags by plan:**
- Starter: RSVP, CALENDAR_INVITE
- Premium: All flags (RSVP, CALENDAR_INVITE, PHOTO_UPLOAD, ANNOUNCEMENT_BANNER, FAQ_SECTION, PASSCODE_SITE)

**Default theme:**
- Primary: #c9826b (terracotta)
- Accent: #8fac8b (sage)
- Neutral Light: #faf8f5 (warm off-white)
- Neutral Dark: #2d2d2d (soft black)

**API Endpoints:**
- `POST /api/billing/stripe-webhook` - Stripe webhook handler
  - Requires `stripe-signature` header
  - Requires raw body for signature verification
  - Handles `checkout.session.completed` to provision weddings
  - Idempotent - same session ID will not create duplicate weddings

**PRD features now passing:**
- "Successful Stripe checkout provisions a wedding" ‚úì

**Next steps:**
- Note: "Wedding site render_config is generated on provisioning" is already implemented as part of this feature
- Next feature should be wedding site rendering from render_config
- Or implement feature toggle UI in admin dashboard

**Notes for next person:**
- In dev mode, weddings and render_configs are stored in-memory (restart API = lose data)
- Webhook requires `STRIPE_WEBHOOK_SECRET` env var for production
- For local testing, use Stripe CLI: `stripe listen --forward-to localhost:3001/api/billing/stripe-webhook`
- Slugs are generated as `partner1-and-partner2-{random}` (URL-safe, lowercase)
- The render_config generation is already in place - provisioning feature passes

---

### 2026-01-06 - Wedding render_config API Endpoint

**Feature worked on:** Wedding site render_config is generated on provisioning (PRD: provisioning category)

**Priority rationale:** This was the highest-priority incomplete feature because:
1. The render_config generation logic was already implemented in WeddingService
2. However, there was no API endpoint to fetch the render_config
3. This blocks the wedding site rendering feature (which needs to consume render_config)
4. Without an endpoint, the PRD step "Fetch wedding_sites.render_config" could not pass

**What was done:**
1. Created WeddingController (services/platform-api/src/wedding/wedding.controller.ts):
   - `GET /api/weddings` - List all weddings for authenticated user
   - `GET /api/weddings/:id` - Get a specific wedding by ID
   - `GET /api/weddings/:id/render-config` - Fetch render_config for a wedding
   - All endpoints require authentication and verify ownership

2. Updated WeddingModule to:
   - Import AuthModule (using forwardRef to avoid circular dependency)
   - Register WeddingController

3. Updated AppModule to:
   - Import WeddingModule directly (previously only imported via BillingModule)

**API Endpoints added:**
- `GET /api/weddings` - Returns user's weddings array
- `GET /api/weddings/:id` - Returns wedding details
- `GET /api/weddings/:id/render-config` - Returns the render_config object containing:
  - `templateId` (e.g., "minimal-001")
  - `theme` (primary, accent, neutralLight, neutralDark)
  - `features` (feature flags record based on plan)
  - `sections` (array of section definitions)
  - `wedding` (slug, partnerNames)

**PRD features now passing:**
- "Wedding site render_config is generated on provisioning" ‚úì

**Next steps:**
- Implement wedding site rendering from render_config (site category)
- This will require updating the Astro wedding site to fetch and render from the config

**Notes for next person:**
- The render_config is stored in-memory alongside weddings (dev mode)
- Endpoint requires Bearer token authentication
- Only the wedding owner can fetch their render_config
- The config contains all data needed for the wedding site to render without additional DB queries

---

### 2026-01-06 - Wedding Site Renders from render_config

**Feature worked on:** Wedding site renders exclusively from render_config (PRD: site category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. It completes the provisioning‚Üírendering pipeline
2. It unblocks all guest-facing features (RSVP, photos, announcements)
3. Without a rendered wedding site, none of the other guest-facing features can be tested
4. It demonstrates the core architecture: platform provisions, site renders

**What was done:**
1. Added public endpoint for wedding site config:
   - `GET /api/site-config/:slug` - No auth required, wedding slug is the identifier
   - Created SiteConfigController (services/platform-api/src/wedding/site-config.controller.ts)
   - Returns render_config for active weddings only

2. Added shared package dependency to wedding-site:
   - Added `@wedding-bestie/shared` workspace dependency for types

3. Created API client for fetching site config:
   - `apps/wedding-site/src/lib/api.ts`
   - `fetchSiteConfig(slug)` - single fetch for all rendering data

4. Created Astro components for wedding site rendering:
   - `WeddingLayout.astro` - Base layout with theme CSS variables and fonts
   - `SectionRenderer.astro` - Maps section types to components, respects feature flags
   - `HeroSection.astro` - Hero section with partner names headline
   - `EventDetailsSection.astro` - Event details with date, venue, city
   - `RsvpSection.astro` - RSVP CTA section (only renders if RSVP feature enabled)

5. Created dynamic route `/w/[slug]`:
   - `apps/wedding-site/src/pages/w/[slug].astro`
   - Fetches render_config via single API call (no database joins)
   - Returns 404 if wedding not found or inactive

**Architecture adherence:**
- Wedding site renders EXCLUSIVELY from render_config (no direct DB queries)
- Single data fetch per page load
- Feature flags respected (RSVP section only shows if feature enabled)
- Theme CSS variables set from render_config theme
- No joins, no multi-table queries

**Design system adherence:**
- Typography: Cormorant Garamond (serif) for headings, Inter (sans) for body
- Colors: Theme-driven via CSS variables (no hardcoded colors)
- No pure black (#000000) or pure white (#FFFFFF)
- Generous whitespace, calm visual style
- Mobile-first responsive design

**API Endpoints added:**
- `GET /api/site-config/:slug` - Public endpoint for wedding site rendering
  - Returns render_config with template, theme, features, sections, wedding info
  - No authentication required
  - Returns 404 for non-existent or inactive weddings

**PRD features now passing:**
- "Wedding site renders exclusively from render_config" ‚úì

**Next steps:**
- Implement template switching feature in admin dashboard
- Or implement guest-facing RSVP flow
- Consider adding announcement banner rendering

**Notes for next person:**
- Wedding sites are at `/w/{slug}` (e.g., `/w/john-and-jane-abc123`)
- The site fetches config from platform-api at startup
- Set `PUBLIC_PLATFORM_API_URL` env var for production deployment
- In dev, defaults to `http://localhost:3001/api`
- To test: create a wedding via Stripe checkout, then visit `/w/{slug}`

---

### 2026-01-06 - Admin Can Add Invitees Manually

**Feature worked on:** Admin can add invitees manually (PRD: guests category)

**Priority rationale:** This is the highest-priority incomplete feature because:
1. It's the foundation for all guest management features
2. Without guests, RSVP and invitation features cannot function
3. It completes the core admin workflow: login ‚Üí create wedding ‚Üí add guests
4. It unblocks downstream features: CSV import, sending invites, RSVP tracking

**What was done:**
1. Added Guest types to shared package:
   - `RsvpStatus` type ('pending' | 'attending' | 'not_attending')
   - `Guest` interface with all guest fields (id, weddingId, name, email, partySize, rsvpStatus, etc.)
   - `CreateGuestRequest` and `UpdateGuestRequest` for API calls
   - `GuestListResponse` for list endpoint
   - Error codes: `GUEST_NOT_FOUND`, `GUEST_ALREADY_EXISTS`, `WEDDING_NOT_FOUND`

2. Created GuestService (services/platform-api/src/guest/guest.service.ts):
   - In-memory storage for development
   - `createGuest()` - creates new guest with RSVP token, checks for duplicate emails
   - `updateGuest()` - updates guest details
   - `deleteGuest()` - removes guest
   - `getGuest()` / `getGuestsForWedding()` - retrieval methods
   - `getGuestSummary()` - aggregates RSVP counts

3. Created GuestController (services/platform-api/src/guest/guest.controller.ts):
   - `GET /api/weddings/:weddingId/guests` - list all guests
   - `POST /api/weddings/:weddingId/guests` - create guest
   - `GET /api/weddings/:weddingId/guests/:guestId` - get single guest
   - `PUT /api/weddings/:weddingId/guests/:guestId` - update guest
   - `DELETE /api/weddings/:weddingId/guests/:guestId` - delete guest
   - All endpoints require authentication and verify wedding ownership

4. Created GuestModule and registered in AppModule

5. Created Guests page component (apps/platform-ui/src/components/Guests.tsx):
   - List view with guest cards showing name, email, RSVP status
   - Add guest form with name and email inputs
   - Delete functionality with confirmation
   - Empty state with friendly messaging
   - Loading states

6. Updated Dashboard component:
   - Now fetches weddings from API on mount
   - Auto-selects first wedding if only one exists
   - Shows wedding selection when multiple weddings
   - WeddingDashboard view with navigation cards
   - "Your guests" card navigates to Guests page
   - "Your site" card links to wedding site

**API Endpoints:**
- `GET /api/weddings/:weddingId/guests` - List guests (requires auth)
- `POST /api/weddings/:weddingId/guests` - Create guest (requires auth)
- `GET /api/weddings/:weddingId/guests/:guestId` - Get guest (requires auth)
- `PUT /api/weddings/:weddingId/guests/:guestId` - Update guest (requires auth)
- `DELETE /api/weddings/:weddingId/guests/:guestId` - Delete guest (requires auth)

**Design system adherence:**
- Calm, minimal UI with intentional whitespace
- Human language: "Your guests", "Add your first guest", "No guests yet"
- RSVP status badges with muted colors
- No pure black/white colors
- Large, clear form inputs

**PRD features now passing:**
- "Admin can add invitees manually" ‚úì

**Next steps:**
- Implement CSV import for bulk guest adding
- Implement invitation sending
- Implement guest-facing RSVP flow

**Notes for next person:**
- Guests are stored in-memory (restart API = lose data)
- Each guest gets a unique RSVP token on creation (32 bytes, hex encoded)
- Duplicate email check is per-wedding (same email can be in different weddings)
- Dashboard auto-selects first wedding if user has only one
- Guest list is sorted alphabetically by name
